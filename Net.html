<!DOCTYPE html>
<html>
<head>
<title>Net.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="file:///Users/linyiting/Downloads/typora-notion-theme-main/themes/enhanced/notion-light-enhanced.css" type="text/css">
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<p>参考：<a href="https://leetcode.cn/leetbook/read/networks-interview-highlights/esegch/">leetcode</a></p>
<h1 id="%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98">常见面试题</h1>
<h2 id="tcpudp">TCP&amp;UDP</h2>
<h3 id="%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8">区别和使用</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>效率</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>所需资源</td>
<td>多</td>
<td></td>
</tr>
<tr>
<td>首部字节</td>
<td>20-60</td>
<td>8</td>
</tr>
<tr>
<td>应用</td>
<td>文件/邮件</td>
<td>即时通讯、域名转换</td>
</tr>
</tbody>
</table>
<p><strong>Q1.</strong> TCP 是如何保证可靠性的</p>
<ul>
<li>
<p>数据分块：应用数据被<strong>分割</strong>成 TCP 认为最适合发送的<strong>数据块</strong>。</p>
</li>
<li>
<p>序列号和确认应答：TCP 给发送的每一个包进行<strong>编号</strong>，在传输的过程中，每次<em><strong>接收方</strong></em>收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行<strong>排序</strong>，把有序数据传送给应用层，并<strong>丢弃重复</strong>的数据。</p>
</li>
<li>
<p>校验和： TCP 将保持它首部和数据部分的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</p>
</li>
<li>
<p>流量控制： TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过<strong>滑动窗口</strong>协议来支持流量控制机制。</p>
</li>
<li>
<p>拥塞控制： 当网络某个节点发生拥塞时，减少数据的发送。</p>
</li>
<li>
<p>ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
</li>
<li>
<p>超时重传： 当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</p>
</li>
</ul>
<p><strong>Q2.</strong> TCP粘包、原因及解决方法</p>
<p>为什么会发生TCP粘包和拆包?</p>
<p>① 发送方写入的数据<strong>大于</strong>套接字缓冲区的大小，此时将发生拆包。</p>
<p>② 发送方写入的数据<strong>小于</strong>套接字缓冲区大小，由于 TCP 默认使用 Nagle 算法，只有当收到一个确认后，才将分组发送给对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包。</p>
<p>③ 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文的数据部分<strong>大于</strong> MSS 的时候将发生拆包。</p>
<p>④ 发送方发送的数据<strong>太快</strong>，接收方处理数据的速度赶不上发送端的速度，将发生粘包。</p>
<p>常见解决方法</p>
<p>① 在消息的头部添加<strong>消息长度字段</strong>，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容。</p>
<p>② 固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法<strong>会浪费网络资源</strong>。</p>
<p>③ 设置消息边界，也可以理解为<strong>分隔符</strong>，服务端从数据流中按消息边界分离出消息内容，一般使用换行符。</p>
<p>什么时候需要处理粘包问题？</p>
<p>当接收端同时收到多个分组，并且这些分组之间毫无关系时，需要处理粘包；而当多个分组属于同一数据的不同部分时，并不需要处理粘包问题。</p>
<p><strong>Q3.</strong> DNS过程，查询自己用过吗？
a记录？SRV?（没听过）</p>
<h3 id="tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">TCP三次握手</h3>
<p><img src="./img/2022-09-19-16-14-26.png" alt=""></p>
<p><strong>过程：</strong></p>
<p>初始状态：客户端【closed】服务端【listen】</p>
<p>step1. 客户端发送【SYN=1，seq=x(一般为随机数)】-&gt; 客户端变为【SYN-SENT】</p>
<p>step2. 服务端收到信息后，返回【SYN=1，ACK=1,seq=y，ack=x+1】-&gt; 服务端变为【SYN-Received】</p>
<p>step3. 客户端收到信息后，返回【ACK=1，seq=x+1，ack=y+1】-&gt; 客户端变为【ESTABLISHED】</p>
<p>step4. 服务端接受信息后-&gt; 服务端变为【ESTABLISHED】</p>
<p><strong>目的：</strong></p>
<ol>
<li>确认双方的收发能力都没有问题</li>
<li>初始化序列号</li>
<li>确认窗口大小即 MSS 等信息</li>
</ol>
<p><strong>Q1.</strong> 如果三次握手的时候每次握手信息对方没有收到会怎么样？</p>
<ol>
<li>若第一次握手服务器未接收到客户端请求建立连接的数据包时：
<ul>
<li>服务器不会进行任何相应的动作，</li>
<li>客户端因此会等待一段时间后重新发送 SYN 同步报文</li>
<li>若仍然没有回应，则重复上述过程直到发送次数超过<strong>最大重传次数限制</strong>后，建立连接的系统调用会返回 -1。</li>
</ul>
</li>
<li>若第二次握手客户端未接收到服务器回应的 ACK 报文时：
<ul>
<li>客户端会采取第一次握手失败时的动作，这里不再重复，</li>
<li>而服务器端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文。</li>
</ul>
</li>
<li>若第三次握手服务器未接收到客户端发送过来的 ACK 报文
<ul>
<li>同样会采取<strong>类似于</strong>客户端的超时重传机制，若重传次数超过限制后仍然没有回应，则 accept() 系统调用返回 -1，服务器端连接建立失败。</li>
<li>但此时<strong>客户端认为自己已经连接成功</strong>了，因此开始向服务器端发送数据，但是服务器端的 accept() 系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会发送 <code>RST 报文</code>给 客户端，消除客户端单方面建立连接的状态。</li>
</ul>
</li>
</ol>
<p><strong>Q2.</strong> 第 2 次握手传回了 ACK，为什么还要传回 SYN?</p>
<ul>
<li>ACK 是为了告诉客户端发来的数据已经接收无误</li>
<li>而传回 SYN 是为了把自己的初始序列号（Seq）同步给客户端。</li>
</ul>
<h3 id="ping">ping</h3>
<p>ping命令本身相当于一个应用程序，位于应用层，</p>
<p>ping使用的是网络层的ICMP协议。</p>
<p>ICMP协议是TCP/IP协议集中的一个子协议，属于网络层协议。</p>
<h3 id="tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">TCP四次挥手</h3>
<p><img src="./img/2022-09-19-16-29-13.png" alt="">
<strong>过程：</strong></p>
<p>初始状态：客户端【ESTABLISHED】服务端【ESTABLISHED】</p>
<p>step1. 客户端发送【FIN=1，seq=u(一般为随机数)】-&gt; 客户端变为【FIN-WAIT-1】即半关闭阶段 -&gt; 并且停止向服务端发送通信数据。</p>
<p>step2. 服务端收到信息后，返回【ACK=1,seq=v，ack=u+1】-&gt; 服务端变为【CLOSED-WAIT】-&gt; 随后服务器开始准备释放服务器端到客户端方向上的连接。</p>
<p>step3. 客户端收到信息后-&gt; 客户端变为【FIN-WAIT-2】</p>
<p>step4. 服务端发出信息后，会将遗留的待传数据传送给客户端，待传输完成后 -&gt; 服务端发出【FIN=1，ACK=1，seq=w，ack=u+1】-&gt; 服务端变为【LAST-ACK】-&gt; 停止向客户端发送数据。</p>
<p>step5. 客户端收到信息后返回【ACK=1,seq=u+1，ack=w+1】-&gt; 客户端变为【TIME-WAIT】-&gt; 等待 2 MSL -&gt; 客户端变为【CLOSED】</p>
<blockquote>
<p>MSL时间 ： windows 120s/linux 60s。所以time-wait时间（2*msl） 挺长的</p>
</blockquote>
<p>step6. 服务端收到信息后-&gt; 服务端变为【CLOSED】</p>
<p><strong>Q1</strong>. <strong>CLOSE-WAIT</strong> 和 <strong>TIME-WAIT</strong> 的状态和意义？</p>
<ul>
<li>
<p><strong>CLOSE-WAIT</strong> 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。</p>
</li>
<li>
<p><strong>TIME-WAIT</strong></p>
<ol>
<li>发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入该状态，若取消该状态，即客户端在收到服务端的 FIN 报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现。</li>
<li>除此之外，假设客户端最后一次发送的 ACK 包在传输的时候丢失了，由于 TCP 协议的超时重传机制，服务端将重发 FIN 报文，若客户端并没有维持 TIME-WAIT 状态而直接关闭的话，当收到服务端重新发送的 FIN 包时，客户端就会用 RST 包来响应服务端，这将会使得对方认为是有错误发生，然而其实只是正常的关闭连接过程，并没有出现异常情况。</li>
</ol>
</li>
</ul>
<h2 id="%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9F%AD%E8%BF%9E%E6%8E%A5">长连接/短连接</h2>
<p><strong>短连接：</strong> 每次请求一个资源就建立一次连接，完成后就关闭</p>
<p><strong>长连接：</strong> 只建立一次连接，多次资源都复用该连接</p>
<p><strong>并行连接：</strong> 并发的短连接</p>
<h3 id="keepalive-tcp%E9%95%BF%E8%BF%9E%E6%8E%A5">Keepalive TCP长连接</h3>
<p><strong>起源：</strong></p>
<p>长连接的环境下，进行一次数据交互后，很长一段时间内无数据交互时，客户端可能意外断电、死机、崩溃、重启，还是中间路由网络无故断开，这些TCP连接并未来得及正常释放，那么，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，且有可能导致在一个无效的数据链路层面发送业务数据，结果就是发送失败。</p>
<p>当客户端端等待超过一定时间后自动给服务端发送一个空的报文，如果对方回复了这个报文证明连接还存活着，如果对方没有报文返回且进行了多次尝试都是一样，那么就认为连接已经丢失，客户端就没必要继续保持连接了。如果没有这种机制就会有很多空闲的连接占用着系统资源。</p>
<p>A和B两边通过三次握手建立好TCP连接，然后突然间B就宕机了，之后时间内B再也没有起来。如果B宕机后A和B一直没有数据通信的需求，A就永远都发现不了B已经挂了，那么A的内核里还维护着一份关于A&amp;B之间TCP连接的信息，浪费系统资源。于是在TCP层面引入了keepalive的机制，A会定期给B发空的数据包，通俗讲就是心跳包，一旦发现到B的网络不通就关闭连接。这一点在LVS内尤为明显，因为LVS维护着两边大量的连接状态信息，一旦超时就需要释放连接。</p>
<p><strong>作用：</strong></p>
<ol>
<li>探测连接的对端是否存活【对端可能断电/死机/崩溃｜中间网络中断】</li>
<li>防止中间设备因为超时删除【连接相关的连接表】</li>
</ol>
<p><strong>http中实现</strong></p>
<ol>
<li>client发出的HTTP请求头需要增加Connection:keep-alive字段</li>
<li>Web-Server端要能识别Connection:keep-alive字段，并且在http的response里指定Connection:keep-alive字段，告诉client，我能提供keep-alive服务，并且&quot;应允&quot;client我暂时不会关闭socket连接</li>
</ol>
<p>在<strong>HTTP/1.0</strong>里，为了实现client到web-server能支持长连接，必须在HTTP请求头里显示指定
<code>Connection:keep-alive</code></p>
<p>在<strong>HTTP/1.1</strong>里，就默认是开启了keep-alive，要关闭keep-alive需要在HTTP请求头里显示指定
<code>Connection:close</code></p>
<ul>
<li>HTTP协议的Keep-Alive意图在于TCP连接复用，同一个连接上串行方式传递请求-响应数据；</li>
<li>TCP的Keepalive机制意图在于探测连接的对端是否存活。</li>
</ul>
<h1 id="%E5%8D%8F%E8%AE%AE%E5%B1%82%E6%AC%A1">协议层次</h1>
<p><img src="./img/2022-10-15-13-14-45.png" alt=""></p>
<h2 id="osi-%E4%B8%83%E5%B1%82">OSI 七层</h2>
<p><strong>1. 应用层</strong></p>
<ul>
<li>通过应用程序间的交互来完成特定的<strong>网络应用</strong>。该层协议定义了应用进程之间的<strong>交互规则</strong>，通过不同的应用层协议为不同的网络应用提供服务。</li>
<li>例如域名系统 <strong>DNS</strong>，支持万维网应用的 <strong>HTTP</strong> 协议，电子邮件系统采用的 <strong>SMTP</strong> 协议等。</li>
<li>在应用层交互的数据单元我们称之为<strong>报文</strong>。</li>
<li>域名组成：主机名.结构名.网络名.顶级域名。</li>
</ul>
<p><strong>2. 表示层</strong></p>
<ul>
<li>表示层的作用是使通信的应用程序能够<strong>解释交换数据的含义</strong>，其位于 OSI 参考模型的第六层，向上为应用层提供服务，向下接收来自会话层的服务。</li>
<li>该层提供的服务主要包括<strong>数据压缩</strong>，<strong>数据加密</strong>以及<strong>数据描述</strong>。这使得应用程序<strong>不必担心</strong>在各台计算机中表示和存储的内部<strong>格式差异</strong>。</li>
</ul>
<p><strong>3. 会话层</strong></p>
<ul>
<li>负责建立、管理和终止表示层实体之间的通信会话。</li>
<li>提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</li>
</ul>
<p><strong>4. 传输层</strong></p>
<ul>
<li>传输层的主要任务是为两台主机进程之间的通信提供服务。</li>
<li>应用程序利用该服务传送应用层<strong>报文</strong>。</li>
<li>该服务并不针对某一特定的应用，<strong>多种应用可以使用同一个传输层服务。</strong></li>
<li>由于一台主机可同时运行多个线程，因此传输层有复用和分用的功能。</li>
<li>所谓<strong>复用</strong>就是指多个应用层进程可同时使用下面传输层的服务，</li>
<li><strong>分用</strong>和复用相反，是传输层把收到的信息分别交付上面应用层中的相应进程。</li>
</ul>
<p><strong>5. 网络层</strong></p>
<ul>
<li>两台计算机之间传送数据时其通信链路往往<strong>不止一条</strong>，所传输的信息甚至可能经过很多通信子网。</li>
<li>网络层的主要任务就是选择合适的<strong>网间路由</strong>和<strong>交换节点</strong>，确保数据按时成功传送</li>
<li>在发送数据时，网络层把传输层产生的报文或用户数据报<strong>封装成分组和包</strong>向下传输到数据链路层</li>
<li>在网络层使用的协议是无连接的网际协议（Internet Protocol）和许多路由协议，因此我们通常把该层简单地称为 <strong>IP 层</strong>。</li>
</ul>
<p><strong>6. 数据链路层</strong></p>
<ul>
<li>两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。</li>
<li>在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送<strong>帧</strong>。</li>
<li>每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。</li>
</ul>
<p><strong>7. 物理层</strong></p>
<ul>
<li>物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</li>
<li>使其上面的数据链路层不必考虑网络的具体传输介质是什么</li>
<li>该层的主要任务是确定与传输媒体的接口的一些特性（机械特性、电气特性、功能特性，过程特性）。</li>
</ul>
<h2 id="tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B4%E5%B1%82">TCP/IP参考模型（4层）</h2>
<p>而 TCP/IP 参考模型直接面向市场需求，实现起来也比较容易，因此在一经提出便得到了广泛的应用。基于 TCP/IP 的参考模型将协议分成四个层次，如上图所示，它们分别是：网络访问层、网际互联层、传输层、和应用层。</p>
<p><strong>1. 应用层</strong></p>
<ul>
<li>TCP/IP 模型将 OSI 参考模型中的<strong>会话层、表示层和应用层</strong>的功能合并到一个应用层实现</li>
<li>通过不同的应用层协议为不同的应用提供服务。例如：FTP、Telnet、DNS、SMTP 等。</li>
</ul>
<p><strong>2. 传输层</strong></p>
<ul>
<li>该层对应于 OSI 参考模型的<strong>传输层</strong></li>
<li>传输层定义了两个主要协议：传输控制协议（TCP）和用户数据报协议（UDP）。</li>
</ul>
<p><strong>3. 网际互联层</strong></p>
<ul>
<li>网际互联层对应 OSI 参考模型的<strong>网络层</strong>，主要负责相同或不同网络中计算机之间的通信。</li>
<li>在网际互联层， IP 协议提供的是一个<strong>不可靠</strong>、<strong>无连接</strong>的数据报传递服务。该协议实现两个基本功能：<strong>寻址</strong>和<strong>分段</strong>。</li>
<li>除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</li>
</ul>
<p><strong>4. 网络接入层</strong></p>
<ul>
<li>对应于 OSI 参考模型中的<strong>物理层</strong>和<strong>数据链路层</strong></li>
<li>负责监视数据在主机和网络之间的交换</li>
</ul>
<h2 id="%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8">数据流动</h2>
<p>应用数据报→传输层报文段→ip成组→链路层成帧→物理层比特流</p>
<table>
<thead>
<tr>
<th>OSI 七层网络模型</th>
<th>TCP/IP 四层概念模型</th>
<th>对应的网络协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层（Application）</td>
<td>应用层</td>
<td>HTTP, TFTP, FTP, NFS, WAIS, SMTP, Telnet, DNS, SNMP</td>
</tr>
<tr>
<td>表示层（Presentation）</td>
<td>~</td>
<td>TIFF, GIF, JPEG, PICT</td>
</tr>
<tr>
<td>会话层（Session）</td>
<td>~</td>
<td>RPC, SQL, NFS, NetBIOS, names, AppleTalk</td>
</tr>
<tr>
<td>传输层（Transport）</td>
<td>传输层</td>
<td>TCP, UDP</td>
</tr>
<tr>
<td>网络层（Network）</td>
<td>网络层</td>
<td>IP, ICMP, ARP, RARP, RIP, IPX</td>
</tr>
<tr>
<td>数据链路层（Data Link）</td>
<td>数据链路层</td>
<td>FDDI, Frame Relay, HDLC, SLIP, PPP</td>
</tr>
<tr>
<td>物理层（Physical）</td>
<td>~</td>
<td>EIA/TIA-232, EIA/TIA-499, V.35, 802.3</td>
</tr>
</tbody>
</table>
<p><img src="./img/2022-12-08-14-03-12.png" alt=""></p>
<h2 id="%E7%BD%91%E7%BB%9C%E5%B1%82">网络层</h2>
<p><strong>Q1</strong> 某学校获取到一个<strong>B类地址段</strong>,要给大家分开子网使用,鉴于现在上网设备急剧增多,管理员给每个网段进行划分的子网掩码设置为<strong>255.255.254.0</strong>,考虑每个网段需要有网关设备<strong>占用一个地址</strong>的情况下,每个网段还有多少可用的主机地址？</p>
<p><strong>IP地址=网络号+主机号</strong></p>
<p>根据子网掩码255.255.254.0，可以看出，前两段都已满，第三段二进制是1111 1110，最后一位可用，最后一段8位可用。
所以可用主机地址为：2^9=512。
全1和全0地址留作特殊用途，题目又说网关设备用一个地址，所以512-3=509</p>
<p><strong>Q2</strong> IP地址200.23.16.0/23的网络掩码为</p>
<p>子网掩码位数等于网络位为1的位数，故等于23，即：11111111.11111111.11111110.00000000 等于255.255.254.0</p>
<h2 id="ipv6">Ipv6</h2>
<p>IPV6地址有128位二进制数组成。每四个二进制数组成一个十六进制数，有128/4=32个十六进制数</p>
<p>每四个十六进制数为一组，中间用冒号隔开。如XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX</p>
<p>如果XXXX四位是全零，可以省略写成::形式</p>
<h3 id="%E7%BD%91%E9%A1%B5%E8%A7%A3%E6%9E%90%E5%85%A8%E8%BF%87%E7%A8%8B%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%98%BE%E7%A4%BA%E5%AF%B9%E5%BA%94%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B">网页解析全过程【用户输入网址到显示对应页面的全过程】</h3>
<p><img src="./img/2022-10-27-14-28-35.png" alt=""></p>
<ol>
<li><strong>DNS解析：<strong>当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要</strong>先把域名转换成相应 IP 地址</strong>。</li>
<li>**TCP连接：**获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP <strong>三次握手</strong>建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了。</li>
<li><strong>发送HTTP请求：<strong>HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个</strong>索要网页</strong>的请求。在这一过程中，会涉及到负载均衡等操作。</li>
<li>**处理请求并返回：**服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。</li>
<li>**浏览器渲染：**首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</li>
<li>**断开连接：**四次挥手</li>
</ol>
<h2 id="http%E5%92%8Chttps">HTTP和HTTPS</h2>
<h3 id="http">HTTP</h3>
<p>HTTP = 超文本传输协议[Hyper Text Transfer Protocol]</p>
<p>它是从<strong>WEB服务器</strong>传输**超文本标记语言(HTML)**到本地浏览器的传送协议。</p>
<ol>
<li>
<p><strong>目的：</strong>
设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</p>
</li>
<li>
<p><strong>原理：</strong></p>
</li>
</ol>
<p>HTTP是一个基于TCP/IP通信协议来传递数据的协议，传输的<strong>数据类型</strong>为HTML 文件,、图片文件, 查询结果等。</p>
<p>HTTP协议一般用于B/S架构（）。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p>
<ol start="3">
<li><strong>特点：</strong></li>
</ol>
<p>a. 客户端/服务端模式，请求/响应模式</p>
<p>b. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</p>
<p>c. 灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</p>
<p>d. 无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。</p>
<p>e. 无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。</p>
<ol start="4">
<li><strong>状态码</strong></li>
</ol>
<p>101 切换协议
200 成功
206 断点续传
301 永久重定向/资源（网页等）被永久转移到其它URL
302 暂时重定向/临时跳转
400 语法错误Bad Request -
403 没有足够的权限Unauthorized
404 找不到对应的资源/请求资源不存在，可能是输入了错误的URL
500 服务器内部错误
502 网关错误 网络错误
503 服务不可用一段时间后可能恢复正常。</p>
<ol start="5">
<li><strong>请求方法</strong></li>
</ol>
<ul>
<li>GET:请求指定的页面信息，并返回实体主体。<strong>get多用来查询</strong>，请求参数放在<strong>url中</strong>，不会对服务器上的内容产生作用。提交的数据<strong>长度是有限制</strong>的，因为URL长度有限制，具体的长度限制视浏览器而定</li>
<li>POST:向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。post用来提交，如把账号密码放入body中。</li>
<li>HEAD:类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</li>
<li>PUT:从客户端向服务器传送的数据取代指定的文档的内容。</li>
<li>DELETE:请求服务器删除指定的页面。</li>
</ul>
<p>6.<strong>缺点</strong></p>
<p>请求信息明文传输，容易被窃听截取。</p>
<p>数据的完整性未校验，容易被篡改</p>
<p>没有验证对方身份，存在冒充危险</p>
<ol start="7">
<li><strong>1.1和2.0</strong></li>
</ol>
<ol>
<li>多路复用
HTTP2.0使用了多路复用的技术，做到同一个连接<strong>并发</strong>处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。</li>
</ol>
<p>HTTP1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。</p>
<p>2） 头部数据
在HTTP1.1中，HTTP请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。</p>
<p>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</p>
<h3 id="https">HTTPS</h3>
<p>为了解决上述HTTP存在的问题，就用到了HTTPS。</p>
<p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过<strong>SSL证书</strong>来验证服务器的<strong>身份</strong>，并为浏览器和服务器之间的通信进行<strong>加密</strong>。</p>
<ol>
<li><strong>SSL[Secure Socket Layer，安全套接字层]</strong></li>
</ol>
<p>位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</p>
<ol start="2">
<li><strong>TLS[Transport Layer Security，传输层安全]</strong></li>
</ol>
<p>其前身是 SSL. 目前使用最广泛的是TLS 1.1、TLS 1.2</p>
<p><img src="./img/2022-10-27-15-22-42.png" alt=""></p>
<p>（1）客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接。</p>
<p>（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p>
<p>（3）客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</p>
<p>（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p>
<p>（5）Web服务器利用自己的私钥解密出会话密钥。</p>
<p>（6）Web服务器利用会话密钥加密与客户端之间的通信。</p>
<ol start="3">
<li><strong>缺点</strong></li>
</ol>
<p>多次握手。加载时间延长50%</p>
<p>连接缓存不如http，增加数据开销和功耗</p>
<p>SSL证书要钱</p>
<p>SSL涉及安全算法会消耗cpu资源，对服务器资源消耗较大</p>
<ol start="4">
<li><strong>握手过程</strong></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/7a3653fdf0664f20b8ed1ba8a2a0159d.png#pic_center" alt=""></p>
<h3 id="%E5%8C%BA%E5%88%AB">区别</h3>
<p>HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。</p>
<p>http和https使用连接方式不同，默认端口也不一样，http是80，https是443。</p>
<h1 id="socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">socket网络编程</h1>
<h2 id="socket%E4%BB%8B%E7%BB%8D">socket介绍</h2>
<p>五层通信流程：</p>
<p><img src="./img/2022-12-08-14-35-04.png" alt=""></p>
<p>socket:</p>
<p><img src="./img/2022-12-08-14-40-20.png" alt=""></p>
<p>socket=套接字，是一组接口。</p>
<p>是[应用层]和[TCP/IP协议族]通信的<strong>中间软件抽象层</strong></p>
<p>socket屏蔽了各个协议的通信细节，使得程序员无需关注协议本身，直接使用socket提供的接口来进行互联的不同主机间的进程的通信。</p>
<h2 id="%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B">网络通信流程</h2>
<ul>
<li>socket对象 = 一部电话</li>
<li>端口+IP = 电话卡</li>
<li>bind(ip_port) = 插上电话卡</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment"># server</span>
<span class="hljs-keyword">import</span> socket
<span class="hljs-comment">#创建一个socket对象</span>
server = socket.socket()  <span class="hljs-comment">#相当于创建了一部电话</span>
ip_port = (<span class="hljs-string">'192.168.111.1'</span>,<span class="hljs-number">8001</span>) <span class="hljs-comment">#创建一个电话卡</span>
server.bind(ip_port) <span class="hljs-comment">#插上电话卡</span>
server.listen(<span class="hljs-number">5</span>) <span class="hljs-comment">#监听着电话，我能监听5个，接到一个电话之后，后面还能有四个人给我打电话，但是后面这四个人都要排队等着，等着我第一个电话挂掉，再来第6个的时候，第六个人的手机会报错</span>
print(<span class="hljs-string">'11111'</span>)
<span class="hljs-comment">#等着别人给我打电话，打来电话的时候，我就拿到了和对方的这个连线通道conn和对方的电话号码addr</span>
conn,addr = server.accept()  <span class="hljs-comment">#阻塞住,一直等到有人连接我，连接之后得到一个元祖，里面是连线通道conn和对方的地址(ip+端口)</span>
print(<span class="hljs-string">'22222'</span>)
print(conn)
print(<span class="hljs-string">'&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;'</span>,addr)
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    from_client_data = conn.recv(<span class="hljs-number">1024</span>) <span class="hljs-comment">#服务端必须通过两者之间的连接通道来收消息</span>
    from_client_data = from_client_data.decode(<span class="hljs-string">'utf-8'</span>)
    print(from_client_data)
    <span class="hljs-keyword">if</span> from_client_data == <span class="hljs-string">'bye'</span>:
        <span class="hljs-keyword">break</span>
    server_input = input(<span class="hljs-string">'明威说&gt;&gt;&gt;&gt;：'</span>)
    conn.send(server_input.encode(<span class="hljs-string">'utf-8'</span>))
    <span class="hljs-keyword">if</span> server_input == <span class="hljs-string">'bye'</span>:
        <span class="hljs-keyword">break</span>
conn.close() <span class="hljs-comment">#挂电话</span>
server.close() <span class="hljs-comment">#关手机</span>

<span class="hljs-comment"># test_server.py</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">#_*_coding:utf-8_*_</span>
<span class="hljs-keyword">import</span> socket
<span class="hljs-keyword">import</span> time

client = socket.socket()
server_ip_port = (<span class="hljs-string">'192.168.111.1'</span>,<span class="hljs-number">8001</span>)

client.connect(server_ip_port)

<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:
    client_input = input(<span class="hljs-string">'小文说&gt;&gt;&gt;&gt;：'</span>)
    client.send(client_input.encode(<span class="hljs-string">'utf-8'</span>)) <span class="hljs-comment">#给服务端发送消息</span>
    <span class="hljs-keyword">if</span> client_input == <span class="hljs-string">'bye'</span>:
        <span class="hljs-keyword">break</span>
    from_server_data = client.recv(<span class="hljs-number">1024</span>)

    print(<span class="hljs-string">'来自服务端的消息：'</span>,from_server_data.decode(<span class="hljs-string">'utf-8'</span>))
    <span class="hljs-keyword">if</span> from_server_data.decode(<span class="hljs-string">'utf-8'</span>) == <span class="hljs-string">'bye'</span>:
        <span class="hljs-keyword">break</span>
client.close() <span class="hljs-comment">#客户端挂电话</span>

<span class="hljs-comment"># test_client.py</span>
</div></code></pre>
<h2 id="tcpudp%E9%80%9A%E8%AE%AF%E6%B5%81%E7%A8%8B%E5%8C%BA%E5%88%AB">TCP/UDP通讯流程区别</h2>
<p><img src="./img/2022-12-09-11-38-07.png" alt=""></p>
<p>TCP和UDP下socket差异对比图：</p>
<p><img src="./img/2022-12-09-11-38-33.png" alt=""></p>
<h3 id="tcp">TCP</h3>
<p><img src="./img/2022-12-09-11-58-38.png" alt=""></p>
<h3 id="udp">UDP</h3>
<p><img src="./img/2022-12-09-13-13-33.png" alt=""></p>
<h2 id="%E5%88%86%E7%B1%BB">分类</h2>
<p>套接字有两种（或者称为有两个种族）,分别是基于文件型的和基于网络型的。</p>
<h3 id="1-%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B">1. 基于文件类型</h3>
<p><strong>AF_UNIX</strong></p>
<p>unix一切皆文件，基于文件的套接字调用的就是底层的<strong>文件系统</strong>来取数据，两个套接字进程运行在<strong>同一机器</strong>，可以通过<strong>访问同一个文件系统间接完成通信</strong></p>
<h3 id="2-%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B">2. 基于网络类型</h3>
<p><strong>AF_INET</strong>
(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我们只使用AF_INET)</p>
<h2 id="%E7%B2%98%E5%8C%85%E7%9B%B8%E5%85%B3">粘包相关</h2>
<p>所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。</p>
<h3 id="%E7%BC%93%E5%86%B2%E5%8C%BA">缓冲区</h3>
<p>每个socket会被分配两个缓冲区，输入缓冲区+输出缓冲区[默认大小一般都是 <code>8K</code>, python可以通过 <code>getsockopt()</code> 函数获取]</p>
<p><code>write()/send()</code> 并<strong>不立即</strong>向网络中传输数据</p>
<ol>
<li>先将数据写入缓冲区中</li>
<li>再由TCP协议将数据<strong>从缓冲区</strong>发送到<strong>目标机器</strong>。</li>
<li>一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。</li>
</ol>
<p><code>read()/recv()</code> 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。</p>
<p><strong>这些I/O缓冲区特性:</strong></p>
<ol>
<li>I/O缓冲区在每个TCP套接字中<strong>单独</strong>存在；</li>
<li>I/O缓冲区在<strong>创建</strong>套接字时<strong>自动生成</strong>；</li>
<li>即使<strong>关闭</strong>套接字也会继续传送<strong>输出</strong>缓冲区中遗留的数据；</li>
<li>关闭套接字将<strong>丢失输入</strong>缓冲区中的数据。</li>
</ol>
<h3 id="%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1">粘包现象</h3>
<p><img src="https://images2018.cnblogs.com/blog/988061/201809/988061-20180906161708494-693168966.png" alt=""></p>
<ol>
<li>数据过大，拆包，有个包和别的包粘着</li>
<li>数据小，多个小包一起发</li>
</ol>
<blockquote>
<p>TCP会粘包，但UDP永远不会</p>
</blockquote>
<ol>
<li>TCP（transport control protocol，传输控制协议）是面向连接的，<strong>面向流</strong>的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（<strong>Nagle</strong>算法），<strong>将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包</strong>。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。</li>
<li>UDP（user datagram protocol，用户数据报协议）是无连接的，<strong>面向消息</strong>的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在<strong>每个UDP包中就有了消息头（消息来源地址，端口等信息</strong>），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是<strong>有消息保护边界</strong>的。</li>
<li>tcp是基于数据流的，于是<strong>收发的消息不能为空</strong>，这就需要在客户端和服务端都添加<strong>空消息的处理机制</strong>，防止程序卡住，而udp是基于数据报的，即便是你输入的是<strong>空内容</strong>（直接回车），那<strong>也不是空消息</strong>，udp协议会帮你封装上消息头，实验略</li>
</ol>
<h2 id="%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%93%BE%E6%8E%A5%E5%90%88%E6%B3%95%E6%80%A7">客户端链接合法性</h2>
<p>连接认证&gt;&gt;身份认证&gt;&gt;ok你可以玩了</p>
<h2 id="socket-%E6%8E%A5%E5%8F%A3">socket 接口</h2>
<p>文件结构</p>
<pre class="hljs"><code><div>file{
  f_type: DTYPE_VNODE || DTYPE_SOCKET // 普通文件｜｜socket对象
  f_ops: socket类型的驱动
  f_data: // 具体的socket结构体
  {
    so_type: 
      SOCK_STREAM  // 提供有序的、可靠的、双向的和基于连接的字节流服务，当使用Internet地址族时使用TCP。
      || SOCK_DGRAM   // 支持无连接的、不可靠的和使用固定大小（通常很小）缓冲区的数据报服务，当使用Internet地址族使用UDP。
      || SOCK_RAW     // 原始套接字，允许对底层协议如IP或ICMP进行直接访问，可以用于自定义协议的开发
    ,
    //每个socket有一个so_pcb，描述了该socket的所有信息
    //而每个socket有一个编号，这个编号就是socket描述符
    so_pcb: {
     inp_laddr, // 当前主机的ip地址
     inp_lport, // 当前主机进程的端口号
     inp_faddr, // 发送端主机的ip地址
     inp_fport  // 发送端主体进程的端口号
    }
  }

}
</div></code></pre>
<h3 id="socket%E5%AE%9E%E4%BE%8B%E6%8E%A5%E5%8F%A3"><code>socket</code>实例接口</h3>
<pre class="hljs"><code><div>  int socket(int protofamily, int so_type, int protocol);
  
</div></code></pre>
<ul>
<li>
<p>protofamily 指协议族</p>
<ul>
<li>AF_INET，指定so_pcb中的地址要采用ipv4地址类型</li>
<li>AF_INET6，指定so_pcb中的地址要采用ipv6的地址类型</li>
<li>AF_LOCAL/AF_UNIX，指定so_pcb中的地址要使用绝对路径名</li>
</ul>
</li>
<li>
<p>so_type</p>
<ul>
<li>SOCK_STREAM:对应tcp</li>
<li>SOCK_DGRAM：对应udp</li>
<li>SOCK_RAW：自定义协议或者直接对应ip层</li>
</ul>
</li>
<li>
<p>protocol 指定具体的协议</p>
<ul>
<li>IPPROTO_TCP，TCP协议</li>
<li>IPPROTO_UDP，UPD协议</li>
<li>0，如果指定为0，表示由内核根据so_type指定默认的通信协议</li>
</ul>
</li>
</ul>
<h3 id="bind%E6%8E%A5%E5%8F%A3"><code>bind</code>接口</h3>
<pre class="hljs"><code><div>  int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
  
</div></code></pre>
<ul>
<li>sockfd 是调用socket()函数创建的socket描述符</li>
<li>addr 是具体的地址</li>
<li>addrlen 表示addr的长度!</li>
</ul>
<p><img src="./img/2022-12-15-14-23-07.png" alt=""></p>
<h3 id="connect%E6%8E%A5%E5%8F%A3"><code>connect</code>接口</h3>
<pre class="hljs"><code><div>  int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
  
</div></code></pre>
<p><strong>三个参数与bind的三个参数含义一致</strong></p>
<p><strong>不过</strong>此处struct sockaddr表示<strong>对端</strong>公开的地址</p>
<p>拿来<strong>建立连接</strong>的函数，只有像<strong>tcp</strong>这样面向连接、提供可靠服务的协议才需要建立连接</p>
<h3 id="listen%E6%8E%A5%E5%8F%A3"><code>listen</code>接口</h3>
<pre class="hljs"><code><div>int listen(int sockfd, int backlog)
</div></code></pre>
<p>告知内核在sockfd这个描述符上监听是否有<strong>连接到来</strong>，并设置同时能完成的<strong>最大连接数</strong>为backlog</p>
<p>当调用listen后，内核就会建立两个队列</p>
<ul>
<li>
<p>一个SYN队列，表示接受到请求，但<strong>未完成</strong>三次握手的连接；</p>
</li>
<li>
<p>另一个是ACCEPT队列，表示<strong>已经完成</strong>了三次握手的队列</p>
</li>
<li>
<p><code>sockfd</code> 是调用socket()函数创建的socket描述符</p>
</li>
<li>
<p><code>backlog</code> 已经完成三次握手而等待accept的连接数</p>
</li>
</ul>
<h3 id="accept%E6%8E%A5%E5%8F%A3">accept接口</h3>
<pre class="hljs"><code><div>int accept(int listen_sockfd, struct sockaddr *addr, socklen_t *addrlen)
</div></code></pre>
<p><strong>三个参数与bind的三个参数含义一致</strong></p>
<p><strong>不过</strong>此处的后两个参数是传出参数</p>
<p>accept函数就是从<strong>ACCEPT队列中</strong>拿一个连接，并<strong>生成</strong>一个新的描述符，新的描述符所指向的结构体so_pcb中的请求端ip地址、请求端端口将被初始化。</p>
<p>返回值是一个新的描述符，我们姑且称之为<code>new_sockfd</code></p>
<ul>
<li>listen_sockfd所指向的结构体so_pcb中的<strong>请求端ip地址</strong>、<strong>请求端端口</strong>没有被初始化，</li>
<li>而new_sockfd的这两个属性被初始化了。</li>
</ul>
<h3 id="listenconnectaccept%E6%B5%81%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86"><code>listen</code>、<code>connect</code>、<code>accept</code>流程及原理</h3>
<p><img src="./img/2022-12-15-14-47-31.png" alt=""></p>
<ol>
<li>服务器调用listen后生成SYN队列和ACCEPT队列，其中ACCEPT队列的长度由backlog指定。</li>
<li>因为此时ACCEPT队列为空，服务器端在调用accept之后，将阻塞，等待ACCEPT队列有元素。</li>
<li>客户端在调用connect之后，将开始发起SYN请求，请求与服务器建立连接，此时称为第一次握手。</li>
<li>服务器端在接受到SYN请求之后，把请求方放入SYN队列中，并给客户端回复一个确认帧ACK，此帧还会携带一个请求与客户端建立连接的请求标志，也就是SYN，这称为第二次握手</li>
<li>客户端收到SYN+ACK帧后，connect返回，并发送确认建立连接帧ACK给服务器端。这称为第三次握手</li>
<li>服务器端收到ACK帧后，会把请求方从SYN队列中移出，放至ACCEPT队列中，而accept函数也等到了自己的资源，从阻塞中唤醒，从ACCEPT队列中取出请求方，重新建立一个新的sockfd，并返回。</li>
</ol>
<h3 id="send-tcp"><code>send()</code>  [TCP]</h3>
<p>send函数只负责将数据提交给协议层。</p>
<p>send<strong>先比较</strong>待发送数据的<strong>长度len</strong>和<strong>套接字s的发送缓冲区</strong>的长度</p>
<ul>
<li>如果len<strong>大于</strong>s的发送缓冲区的长度，该函数返回<code>SOCKET_ERROR</code>；</li>
<li>如果len<strong>小于或者等于</strong>s的发送缓冲区的长度，那么send先检查协议<strong>是否正在发送</strong>s的发送缓冲中的数据；
<ul>
<li>如果<strong>是</strong>就等待协议把数据<strong>发送完</strong></li>
<li>如果<strong>协议还没有开始</strong>发送s的发送缓冲中的数据<strong>或者</strong>s的发送缓冲中<strong>没有数据</strong>
<ul>
<li>那么send就比较s的发送缓冲区的<strong>剩余空间</strong>和<strong>len</strong>；
<ul>
<li>如果len<strong>大于</strong>剩余空间大小，send就一直等待协议把s的发送缓冲中的数据发送完，</li>
<li>如果len<strong>小于</strong>剩余空间大小
<ul>
<li>send就仅仅把buf中的数据copy到剩余空间里（注意并不是send把s的发送缓冲中的数据传到连接的另一端的，而是<strong>协议</strong>传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里）。</li>
<li>如果send函数<strong>copy数据成功</strong>，就<strong>返回</strong>实际copy的<strong>字节数</strong>，</li>
<li>如果send在<strong>copy数据</strong>时<strong>出现错误</strong>，那么send就返回<code>SOCKET_ERROR</code>；</li>
<li>如果send在等待<strong>协议传送数据时网络断开</strong>的话，那么send函数也返回<code>SOCKET_ERROR</code>。要注意send函数把buf中的数据成功copy到s的发送缓冲的剩余空间里后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。</li>
<li>如果<strong>协议在后续的传送过程中出现网络错误</strong>的话，那么<strong>下一个Socket</strong>函数就会返回<code>SOCKET_ERROR</code>。（每一个<strong>除send外</strong>的Socket函数在执行的<strong>最开始总要先等待</strong>套接字的<strong>发送缓冲中的数据被协议传送完毕</strong>才能继续，如果在等待时出现网络错误，那么该Socket函数就返回SOCKET_ERROR）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="recv-tcp"><code>recv()</code>  [TCP]</h3>
<ul>
<li>recv先<strong>检查</strong>套接字<strong>s的接收缓冲区</strong>
<ul>
<li>如果s接收缓冲区中<strong>没有数据</strong>或者协议<strong>正在接收数据</strong>
<ul>
<li>那么<code>recv</code>就一直<strong>等待</strong>，直到协议把数据<strong>接收完毕</strong>。</li>
</ul>
</li>
<li>当协议把数据接收完毕，<code>recv</code>函数就把s的接收缓冲中的<strong>数据copy到buf中</strong>（注意协议接收到的数据可能<strong>大于</strong>buf的长度，所以在这种情况下要<strong>调用几次</strong>recv函数才能把s的接收缓冲中的数据copy完。<strong>recv函数仅仅是copy数据</strong>，真正的接收数据是协议来完成的）</li>
<li>recv函数<strong>返回</strong>其<strong>实际copy的字节数</strong>。</li>
<li>如果recv在copy时<strong>出错</strong>，那么它返回<code>SOCKET_ERROR</code>；</li>
<li>如果recv函数在等待协议接收数据时<strong>网络中断</strong>了，那么它返回<code>0</code> 。</li>
<li>对方优雅的关闭socket并不影响本地recv的正常接收数据；
<ul>
<li>如果<strong>协议缓冲区</strong>内<strong>没有数据</strong>，recv返回<code>0</code>，指示对方关闭；</li>
<li>如果<strong>协议缓冲区****有数据</strong>，则<strong>返回对应数据</strong>(可能需要多次recv)，在<strong>最后一次recv时，返回0</strong>，指示对方关闭。</li>
</ul>
</li>
</ul>
</li>
</ul>

</body>
</html>
