
## 正则表达式
### 元字符
[更多详情](https://www.runoob.com/regexp/regexp-metachar.html)

**^**  匹配输入字符串的**开始位置**

**$**  匹配输入字符串的**结束位置**

**\***  匹配前面的**子表达**式零次或多次。例如，zo* 能匹配 "z"(0次) 以及 "zoo"(2次)。* 等价于`{0,}`。

**+**  匹配前面的子表达式一次或多次。例如，zo* 能匹配 "zo"(1次) 以及 "zoo"(2次)。* 等价于`{1,}`。

**?**  
1. 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。
2. 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而**默认的贪婪模式**则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。


**{n}**  n是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob"(1次) 中的 'o'，但能匹配 "foooood"(5次) 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。

**{n,m}**  m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。

**.** 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"(.|\n)"的模式。

**x|y** 或



---
## 常用Shell
### grep
我们可以使用grep命令在文本中查找指定的字符串，就像你在windows中打开txt文件，使用快捷键 “Ctrl+F” 在文本中查找某个字符串一样，说白了，可以把grep理解成字符查找工具。

grep是Linux中最常用的”文本处理工具”之一，*grep*与*sed*、*awk*合称为Linux中的三剑客。

**-i** 默认情况下，grep是区分**大小写**的。使用”`-i`”在搜索时不区分大小写
```
eg. grep -i "[search text]" [filename]
```
**-n** 想要知道哪行文本包含”[search text]”字符串，则可以使用”`-n`”选项，会显示出现查找到的行内容和行号

**-c** 可只统计符合条件的**总行数**，而不会打印出行。

**-o** 可只打印出匹配到的关键字，而不打印出整行。但是要注意，出现在同一行的关键字也会分行打印出来

**-A -B -C** A=after B=before C=A+B A1=after 1 line
```
eg. grep -A3 "111" [filename]
result:
111
111出现的下三行内容

```

**-w** 精准匹配。 比如说搜索“zsy”出现的是zsy单独出现的行，而不是类似“lszsydd”这种。

**-v** 反向查找。 输出不包含[search text]的内容

**-e** 同时从多个目标中匹配.包含这n个字符串中任意一个的行都会被打印出来.多个目标之间存在**或**关系，即匹配其中的任意一个都算作匹配成功

**-q** 静默模式。不会输出任何信息。 需要`echo $?`命令查看执行状态。 返回0，说明匹配到了，返回1则相反。

**-E** 除了使用字符串也可以用正则搜索。在使用”-E”选项时，grep才支持”扩展正则表达式”，不使用”-E”选项时，grep默认只支持”基本正则表达式”。

grep：支持基本正则表达式

egrep：支持扩展正则表达式，相当于grep -E

fgrep：不支持正则表达式，只能匹配写死的字符串，但是速度奇快，效率高，fastgrep

```
总结
–color=auto 或者 –color：表示对匹配到的文本着色显示

-i：在搜索的时候忽略大小写

-n：显示结果所在行号

-c：统计匹配到的行数，注意，是匹配到的总行数，不是匹配到的次数

-o：只显示符合条件的字符串，但是不整行显示，每个符合条件的字符串单独显示一行

-v：输出不带关键字的行（反向查询，反向匹配）

-w：匹配整个单词，如果是字符串中包含这个单词，则不作匹配

-Ax：在输出的时候包含结果所在行之后的指定行数，这里指之后的x行，A：after

-Bx：在输出的时候包含结果所在行之前的指定行数，这里指之前的x行，B：before

-Cx：在输出的时候包含结果所在行之前和之后的指定行数，这里指之前和之后的x行，C：context

-e：实现多个选项的匹配，逻辑or关系

-q：静默模式，不输出任何信息，当我们只关心有没有匹配到，却不关心匹配到什么内容时，我们可以使用此命令，然后，使用”echo $?”查看是否匹配到，0表示匹配到，1表示没有匹配到。

-P：表示使用兼容perl的正则引擎。

-E：使用扩展正则表达式，而不是基本正则表达式，在使用”-E”选项时，相当于使用egrep。
```
## 文件权限
- 每个Linux文件具有四种访问权限：
  - 可读(r)、可写(w)、可执行(x)和无权限(-)。

利用`ls -l`命令可以看到某个文件或目录的权限，它以显示数据的第一个字段为准。第一个字段由10个字符组成，如下：
```
    （u）           （o）
  2-4位表示文件   所有者所属组之外
  所有者的权限     的用户的权限
      |   ｜      ｜   ｜
    - r w x r - x r - x
    |       ｜  ｜
第一位表示 5-7位表示文件
文件类型   所有者所属组成员的权限
            （g）


```
以上例子表示这是一个文件(非目录），文件所有者具有读、写和执行的权限，所有者所属组成员和所属组之外的用户具有读和执行的权限而没有写的权限。

2-10位的权限总和有时称为a权限

### 文件权限更改
1. 数字表示
```
   r = 4
   w = 2
   x = 1
   无 = 0

   rwxrwxr-x 
   = ((0b111)(0b111)(0b101))
   = 775

   rwxr-xr-x
   = (0b111)(0b101)(0b101)
   = 755
```
2. 修改命令
- 使用数字
  -  ` chmod 664 test`
  -  将文件test的权限修改为所有者和组成员具有读写的权限，其他人只有读权限
+ 使用文本
  + u：所有者
  + g：组成员
  + o：其他成员
  + a：所有人
  + 权限仍用r、w和x表示
  + 文本表示法不仅可以重新指定权限，也可以在原来权限的基础上增加或减少权限，如下
  +  =：重新制定权限
  + -：对目前的设置减少权限
  + +：对目前的设置增加权限
  + `chmod u+x,g-x,o=x test` 逗号前后没有空格

3. 目录权限

    目录权限的修改和文件权限修改不同，只是四种权限代表的含义如下：

    r：可列出目录中的内容

    w：可在目录中创建、删除和修改文件

    x：可以使用cd命令切换到此目录

    -：没有任何此目录的访问权限

> 注意：目录可以使用通配符"*"来表示目录中的所有文件，如将/test目录中的所有文件的权限设置为任何人都可以读写
`chmod 666 /test/*`

4. 默认权限掩码-----umask
权限掩码有4个八进制的数字组成，现有的权限减掉权限掩码后，即可产生此文件建立时的默认权限。

一般来说，新建文件的默认值是`0666`，新建目录的默认值是`0777`，如果将全线掩码设置为`0002`，则每个新建文件的默认权限为0666-0002=0664，而目录的默认权限则为`775`。可以直接输入umask命令来检查目前的默认权限掩码，或输入"`umask` 权限掩码"来指定默认权限掩码。用`umask`的方式指定默认权限掩码，可以**避免添加访问权限过大**的文件或目录。
# 进程
+ 进程是处于执行期的程序以及相关资源的总称
+ 内核调度的对象是线程,而不是进程
+ 当进程处于TASK_UNINTERRUPTIBLE状态时不可以被杀死
+ 线程被视为一个与其他进程共享某些资源的进程
## 孤儿进程/僵尸进程/守护进程
### 孤儿进程
父进程在子进程推退出之前就结束了自己的生命，此时的子进程叫做孤儿进程。

孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。

每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。

这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。
因此**孤儿进程并不会有什么危害** 。
### 僵尸进程
一个子进程在其父进程还没有调用wait()或waitpid()的情况下退出。这个子进程就是僵尸进程。

任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是**每个**子进程在结束时都要经过的阶段。

如果子进程在exit()之后，父进程没有来得及处理，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的

如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。
### 守护进程
守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。

- 很多守护进程在**系统引导**的时候启动，并且一直运行直到系统关闭。

- 另一些只在需要的时候才启动，完成任务后就自动结束。

用户使守护进程**独立于所有终端**是因为，在守护进程从一个终端启动的情况下，这同一个终端可能被其他的用户使用。

例如，用户从一个终端启动守护进程后退出，然后另外一个人也登录到这个终端。

用户不希望后者在使用该终端的过程中，接收到守护进程的任何错误信息。同样，由终端键人的任何信号(例如中断信号)也不应该影响先前在该终端启动的任何守护进程的运行。

虽然让服务器后台运行很容易(只要shell命令行以&结尾即可)，但用户还应该做些工作，让程序本身能够自动进入后台，且不依赖于任何终端。

- 系统守护进程：syslogd、login、crond、at等。
- 网络守护进程：sendmail、httpd、xinetd、等。
- 独立启动的守护进程：httpd、named、xinetd等。
- 被动守护进程（由xinetd启动）：telnet、finger、ktalk等。