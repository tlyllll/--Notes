<!-- TOC -->

    - [正则表达式](#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)
        - [元字符](#%E5%85%83%E5%AD%97%E7%AC%A6)
    - [常用Shell](#%E5%B8%B8%E7%94%A8shell)
        - [grep](#grep)
    - [文件权限](#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90)
        - [文件权限更改](#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E6%9B%B4%E6%94%B9)
- [进程](#%E8%BF%9B%E7%A8%8B)
    - [临界区](#%E4%B8%B4%E7%95%8C%E5%8C%BA)
    - [进程状态变化](#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96)
    - [进程间通信](#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1)
        - [pipe 管道](#pipe-%E7%AE%A1%E9%81%93)
        - [消息队列](#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97)
        - [信号量 【同步/互斥】](#%E4%BF%A1%E5%8F%B7%E9%87%8F-%E5%90%8C%E6%AD%A5%E4%BA%92%E6%96%A5)
        - [共享内存](#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98)
        - [socket](#socket)
    - [死锁](#%E6%AD%BB%E9%94%81)
    - [孤儿进程/僵尸进程/守护进程](#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B)
        - [孤儿进程](#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B)
        - [僵尸进程](#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B)
        - [守护进程](#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B)
    - [文件系统](#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F)
    - [分时系统/实时系统](#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F)
        - [分时操作系统](#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)
        - [实时操作系统](#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)
        - [比较](#%E6%AF%94%E8%BE%83)
    - [操作系统调度算法](#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)
        - [**FCFS** 先来先服务](#fcfs-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1)
        - [**SJF/SPF** 短作业/短进程优先算法](#sjfspf-%E7%9F%AD%E4%BD%9C%E4%B8%9A%E7%9F%AD%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95)
        - [**RR** 时间片轮转调度算法](#rr-%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)
    - [页面置换算法](#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95)
        - [**OPT** 最佳置换算法](#opt-%E6%9C%80%E4%BD%B3%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95)
        - [**FIFO** 先进先出置换算法](#fifo-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95)
        - [**LRU** 最近最久未使用置换算法](#lru-%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95)

<!-- /TOC -->
## 正则表达式

### 元字符
[更多详情](https://www.runoob.com/regexp/regexp-metachar.html)

**^**  匹配输入字符串的**开始位置**

**$**  匹配输入字符串的**结束位置**

**\***  匹配前面的**子表达**式零次或多次。例如，zo* 能匹配 "z"(0次) 以及 "zoo"(2次)。* 等价于`{0,}`。

**+**  匹配前面的子表达式一次或多次。例如，zo* 能匹配 "zo"(1次) 以及 "zoo"(2次)。* 等价于`{1,}`。

**?**  
1. 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。
2. 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而**默认的贪婪模式**则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。


**{n}**  n是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob"(1次) 中的 'o'，但能匹配 "foooood"(5次) 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。

**{n,m}**  m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。

**.** 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用像"(.|\n)"的模式。

**x|y** 或



---

## 常用Shell

### grep
我们可以使用grep命令在文本中查找指定的字符串，就像你在windows中打开txt文件，使用快捷键 “Ctrl+F” 在文本中查找某个字符串一样，说白了，可以把grep理解成字符查找工具。

grep是Linux中最常用的”文本处理工具”之一，*grep*与*sed*、*awk*合称为Linux中的三剑客。

**-i** 默认情况下，grep是区分**大小写**的。使用”`-i`”在搜索时不区分大小写
```
eg. grep -i "[search text]" [filename]
```
**-n** 想要知道哪行文本包含”[search text]”字符串，则可以使用”`-n`”选项，会显示出现查找到的行内容和行号

**-c** 可只统计符合条件的**总行数**，而不会打印出行。

**-o** 可只打印出匹配到的关键字，而不打印出整行。但是要注意，出现在同一行的关键字也会分行打印出来

**-A -B -C** A=after B=before C=A+B A1=after 1 line
```
eg. grep -A3 "111" [filename]
result:
111
111出现的下三行内容

```

**-w** 精准匹配。 比如说搜索“zsy”出现的是zsy单独出现的行，而不是类似“lszsydd”这种。

**-v** 反向查找。 输出不包含[search text]的内容

**-e** 同时从多个目标中匹配.包含这n个字符串中任意一个的行都会被打印出来.多个目标之间存在**或**关系，即匹配其中的任意一个都算作匹配成功

**-q** 静默模式。不会输出任何信息。 需要`echo $?`命令查看执行状态。 返回0，说明匹配到了，返回1则相反。

**-E** 除了使用字符串也可以用正则搜索。在使用”-E”选项时，grep才支持”扩展正则表达式”，不使用”-E”选项时，grep默认只支持”基本正则表达式”。

grep：支持基本正则表达式

egrep：支持扩展正则表达式，相当于grep -E

fgrep：不支持正则表达式，只能匹配写死的字符串，但是速度奇快，效率高，fastgrep

```
总结
–color=auto 或者 –color：表示对匹配到的文本着色显示

-i：在搜索的时候忽略大小写

-n：显示结果所在行号

-c：统计匹配到的行数，注意，是匹配到的总行数，不是匹配到的次数

-o：只显示符合条件的字符串，但是不整行显示，每个符合条件的字符串单独显示一行

-v：输出不带关键字的行（反向查询，反向匹配）

-w：匹配整个单词，如果是字符串中包含这个单词，则不作匹配

-Ax：在输出的时候包含结果所在行之后的指定行数，这里指之后的x行，A：after

-Bx：在输出的时候包含结果所在行之前的指定行数，这里指之前的x行，B：before

-Cx：在输出的时候包含结果所在行之前和之后的指定行数，这里指之前和之后的x行，C：context

-e：实现多个选项的匹配，逻辑or关系

-q：静默模式，不输出任何信息，当我们只关心有没有匹配到，却不关心匹配到什么内容时，我们可以使用此命令，然后，使用”echo $?”查看是否匹配到，0表示匹配到，1表示没有匹配到。

-P：表示使用兼容perl的正则引擎。

-E：使用扩展正则表达式，而不是基本正则表达式，在使用”-E”选项时，相当于使用egrep。
```

## 文件权限
- 每个Linux文件具有四种访问权限：
  - 可读(r)、可写(w)、可执行(x)和无权限(-)。

利用`ls -l`命令可以看到某个文件或目录的权限，它以显示数据的第一个字段为准。第一个字段由10个字符组成，如下：
```
    （u）           （o）
  2-4位表示文件   所有者所属组之外
  所有者的权限     的用户的权限
      |   ｜      ｜   ｜
    - r w x r - x r - x
    |       ｜  ｜
第一位表示 5-7位表示文件
文件类型   所有者所属组成员的权限
            （g）


```
以上例子表示这是一个文件(非目录），文件所有者具有读、写和执行的权限，所有者所属组成员和所属组之外的用户具有读和执行的权限而没有写的权限。

2-10位的权限总和有时称为a权限

### 文件权限更改
1. 数字表示
```
   r = 4
   w = 2
   x = 1
   无 = 0

   rwxrwxr-x 
   = ((0b111)(0b111)(0b101))
   = 775

   rwxr-xr-x
   = (0b111)(0b101)(0b101)
   = 755
```
2. 修改命令
- 使用数字
  -  ` chmod 664 test`
  -  将文件test的权限修改为所有者和组成员具有读写的权限，其他人只有读权限
+ 使用文本
  + u：所有者
  + g：组成员
  + o：其他成员
  + a：所有人
  + 权限仍用r、w和x表示
  + 文本表示法不仅可以重新指定权限，也可以在原来权限的基础上增加或减少权限，如下
  +  =：重新制定权限
  + -：对目前的设置减少权限
  + +：对目前的设置增加权限
  + `chmod u+x,g-x,o=x test` 逗号前后没有空格

3. 目录权限

    目录权限的修改和文件权限修改不同，只是四种权限代表的含义如下：

    r：可列出目录中的内容

    w：可在目录中创建、删除和修改文件

    x：可以使用cd命令切换到此目录

    -：没有任何此目录的访问权限

> 注意：目录可以使用通配符"*"来表示目录中的所有文件，如将/test目录中的所有文件的权限设置为任何人都可以读写
`chmod 666 /test/*`

4. 默认权限掩码-----umask
权限掩码有4个八进制的数字组成，现有的权限减掉权限掩码后，即可产生此文件建立时的默认权限。

一般来说，新建文件的默认值是`0666`，新建目录的默认值是`0777`，如果将全线掩码设置为`0002`，则每个新建文件的默认权限为0666-0002=0664，而目录的默认权限则为`775`。可以直接输入umask命令来检查目前的默认权限掩码，或输入"`umask` 权限掩码"来指定默认权限掩码。用`umask`的方式指定默认权限掩码，可以**避免添加访问权限过大**的文件或目录。

# 进程
+ 进程是处于执行期的程序以及相关资源的总称
+ 内核调度的对象是线程,而不是进程
+ 当进程处于TASK_UNINTERRUPTIBLE状态时不可以被杀死
+ 线程被视为一个与其他进程共享某些资源的进程
+ 就绪状态 >>> 运行状态 (这个过程会出现**任务调度**)

## 临界区
+ 每个进程中访问临界资源的那段程序 == 临界区
+ 临时资源 == 一次仅一个进程使用的共享资源
+ 打印机/磁带机 = 临界资源【硬件】
+ 消息缓冲队列/变量/数组/缓冲区 = 临界资源【软件】

## 进程状态变化
```
                            等待某事件（如i/o请求）
                    【阻塞】<------------
等待的事件发生（如i/o结束）↓               |
【新建】--(允许进入)-->【就绪】--(调度)->【运行】--(终止进程)-->【终止】 
                       ↑               |
                       ----(时间片完)----
 
```
- P、V操作是一种低级进程通讯**原语**
- 原语有**不可中断**性，它是通过在执行过程中关闭中断实现的，且一般由系统进程调用。
## 进程间通信
### 1. pipe 管道
**匿名管道‘｜’** 
1. 表示把进程A的输出传输到进程B
2. 如echo "happy" | xxx
   
**命名管道** 
1. mkfifo <pipename>
2. echo '1' > pipe 
3. cat <pipe>
4. 如果一直没有接受命令，则左边发送窗口会一直堵塞 

**缺点**：速度慢【只能父子进程通信(匿名)】+数据块最大长度有限制
### 2. 消息队列
进程A --【数据块】-->进程B

避免命名管道的同步和阻塞问题

缺点：数据块最大长度有限制 + 如果频繁通信相当于间接拷贝进程，比较费时+要注意上次没读完的数据
### 3. 信号量 【同步/互斥】
同步 
```
S1: 
signal(mutex);
S2:
wait(mutex);
```
互斥 
```
S1: 
wait(mutex);
signal(mutex);
//信号量初始值=1
// wait 和 signal成对出现
```
### 4. 共享内存
让2个进程各自拿出一块虚拟内存空间映射到同一物理内存

**优点**：解决拷贝所消耗的时间


### 5. socket
## 死锁
**必要条件**：
1. 互斥，该资源一次只能被一个进程使用
2. 请求并保持：对已经获得的资源不放手，且请求新的资源
3. 不可剥夺：该资源只能由该进程释放
4. 环路等待

**预防**：
1. 对应上面（2.）一次分配完所有资源，要啥给啥，只要有一个资源给不了，其他的也不给
2. 对应上面（3.）当某进程获得部分资源，但得不到剩下的就释放
3. 对应上面（4.）给资源有序放号，按号码去请求获得资源，释放时相反+  超时释放
## 孤儿进程/僵尸进程/守护进程

### 孤儿进程
父进程在子进程推退出之前就结束了自己的生命，此时的子进程叫做孤儿进程。

孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。

每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。

这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。
因此**孤儿进程并不会有什么危害** 。

### 僵尸进程
一个子进程在其父进程还没有调用wait()或waitpid()的情况下退出。这个子进程就是僵尸进程。

任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是**每个**子进程在结束时都要经过的阶段。

如果子进程在exit()之后，父进程没有来得及处理，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的

如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。

### 守护进程
守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。

- 很多守护进程在**系统引导**的时候启动，并且一直运行直到系统关闭。

- 另一些只在需要的时候才启动，完成任务后就自动结束。

用户使守护进程**独立于所有终端**是因为，在守护进程从一个终端启动的情况下，这同一个终端可能被其他的用户使用。

例如，用户从一个终端启动守护进程后退出，然后另外一个人也登录到这个终端。

用户不希望后者在使用该终端的过程中，接收到守护进程的任何错误信息。同样，由终端键人的任何信号(例如中断信号)也不应该影响先前在该终端启动的任何守护进程的运行。

虽然让服务器后台运行很容易(只要shell命令行以&结尾即可)，但用户还应该做些工作，让程序本身能够自动进入后台，且不依赖于任何终端。

- 系统守护进程：syslogd、login、crond、at等。
- 网络守护进程：sendmail、httpd、xinetd、等。
- 独立启动的守护进程：httpd、named、xinetd等。
- 被动守护进程（由xinetd启动）：telnet、finger、ktalk等。


## 文件系统
就是负责把用户的文件存到**磁盘硬件**中，因为即使计算机断电了，磁盘里的数据并不会丢失，所以可以持久化的保存文件。

文件系统 = 操作系统对文件管理的部分 

文件存储结构=文件物理结构=磁盘文件结构

基本数据单位 = 文件

**主要目的**：管理文件的存储空间实施空间的分配与回收。目的是对磁盘上的文件进行组织管理。

文件系统用**目录**组织文件

Linux 文件系统会为每个文件分配两个数据结构：
- **索引节点**（index node/ inode）：主要用来记录文件的**元信息**（比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等）。索引节点是文件的**唯一**标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样**占用**磁盘空间。
- **目录项**（directory entry/ dentry）：**目录层次结构**(文件的名字、索引节点指针以及与其他目录项的层级关联关系)。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个**数据结构**，**不存放于磁盘**，而是缓存在**内存**。

**连续文件**类似于数组，顺序访问速度快，但是增删数据时要移动其他数据块，所以速度很慢，当文件很大时，增删文件内容会非常痛苦；

**链接文件**类似于链表，随机访问速度慢，增删数据很快，不需要移动数据块，只需要改变指针指向即可，当文件很大时，随机访问文件内容可能非常慢；

**索引文件**糅合了连续文件和链接文件，但更适合大文件；

**多级索引**结构中级数越高适用的文件越大，但是出现相对较小文件时又会造成磁盘空间浪费，

**混合索引结构**更灵活，可以既包括单索引，又包括二级索引，甚至包括三级，四级甚至更高级，能够兼容各个量级的大文件。

**Windows使用显式链接文件**

**Q1** 下面关于文件系统，描述不正确的是？（ACD）
- 进程终止后，这个进程所打开的文件也会被系统删除
- 删除一个文件，同时会删除与此文件对应的文件控制块
- 一个文件在磁盘上存放的磁盘块必须是相邻的
- 符号连接所连接的文件被删除后，符号连接也会消失


## 分时系统/实时系统

### 分时操作系统

多个人同时连在计算机上，每个人看作是另外一个I/O终端，每个用户拥有一个终端显示器，这些终端显示器与计算机连接。

**终端显示器**只能接受和发送*有限*的**文本命令和信息**。

计算机在所有连接的终端用户之间进行分时，即分给每个人有限的时间，只要时间到了，就换一个进程。这种时分切换下的操作系统就是分时操作系统。

**特点：**
- 在分时操作系统下，**任意时间**可以运行多个程序，且用户直接与计算机交互。
- 分时系统是人等机器。
- 多路性：多个用户可以**同时使用**计算机 (同时性)
- 交互性：用户**直接控制**操作过程 (终端)
- 独立性：程序之间相互独立，多个用户同时使用，**每个用户感觉独占计算机系统**
- 及时性：用户请求在很**短时间**响应

### 实时操作系统
实时操作系统：是指所有任务都在**规定时间内完成**的操作系统，即必须满足**时序可预测性**。

实时操作，并不是反应很快的系统，而是反应具有时序可预测性的系统。

**特点：**
- 实时操作系统对**可靠性**和**可用性**要求也非常高。
- 实时系统用于**控制实时过程**，所以要求对外部事件的**响应要十分及时**，迅速。能迅速处理外部中断，较常用的中断处理程序及有关的系统数据最好常驻主存储器中。

### 比较
1、多路性

实时系统与分时系统**一样**具有多路性

- 分时系统按分时原则为**多个终端用户**服务；

- 而实时系统，其多路性则主要表现在经常对**多路的现场信息**进行采集及对**多个对象**或**多个执行机构**进行控制。

2、独立性

实时系统与分时系统**一样**具有独立性。每个终端用户在向实时系统提出服务请求时，是彼此独立的操作，互不干扰；而且在实时系统中**信息的采集**和对**对象的控制**也是彼此互不干扰的。

3、及时性

实时系统对实时性的要求与分时系统**类似**，都是以人能接受的等待时间来确定；但实时系统的及时性，则是以控制对象所要求的开始截止时间或完成截止时间来确定的，一般为秒级、百毫秒直至毫秒级，甚至有的要低于100μs。

4、交互性

实时系统具有交互性，但这里人与系统的交换，**仅限于**访问系统中某些特定的专用**服务程序**。

它不像分时系统那样能向终端用户提供**数据处理服务**、**资源共享**等服务。

5、可靠性

分时系统要求系统可靠，相比之下，实时系统则要求系统**高度**可靠。因为任何差错都可能带来巨大的经济损失，甚至无法预料的灾难后果。因此，在实时系统中，采取了**多级容错措施**来保证系统的安全及数据的安全。

## 操作系统调度算法
### 1. **FCFS** 先来先服务

对于进程调度来说，一旦一个进程得到处理机，它就**一直运行**下去，直到该进程**完成任务**或者**因等待某事件**而不能继续运行，才会让出处理机

先来先服务调度算法属于**非剥夺**方式。

该算法现在已经很少作为主要的调度算法单独使用，尤其在分时操作系统和实时操作系统中，通常是与其他调度算法结合使用。

### 2. **SJF/SPF** 短作业/短进程优先算法
短进程优先调度算法从进程的就绪队列中挑选那些运行时间（估计时间）**最短的进程**进入主存运行。

这是一个**非剥夺算法**。它一旦选中某个短进程，就应该保证该进程尽可能快地完成运行并退出系统。

就绪队列中等待的**进程数↓**，进程的**平均等待时间↓**，系统的**吞吐量↑**。

**But：**
1. 各进程的等待时间的变化范围较大，并且进程（尤其是大进程）的等待时间**难以预先估计**。也就是说，用户对他的进程什么时候完成心里没底。而在先来先服务调度算法中，进程的等待和完成时间是**可以预期**的。
2. 这样，当后续短进程过多时，大进程可能没有机会运行，导致**饿死**。
### 3. **RR** 时间片轮转调度算法
时间片轮转调度算法（Round Robin）主要用于**低级调度**。

其进程就绪队列往往按进程**到达的时间**来排序。

进程调度程序总是选择就绪队列中的第一个进程，也就是说，按照先来先服务原则进行调度，但进程仅占用处理机一个时间片。即使进程还没有完成其运行，它也必须让出（**被剥夺**）处理机给下一个就绪的进程。而被剥夺的进程返回就绪队列的末尾重新排队，等候再次运行。

时间片轮转调度算法特别适合**分时系统**使用。

当多个进程驻留主存时，在进程间转接的开销一般不是很大

特别要注意的是，时间片是否用完的判定程序是由**时钟中断处理程序**激活的，因此时间片值**必须大于**时钟中断间隔。

## 页面置换算法
替换时缺页率+1
### 1. **OPT** 最佳置换算法
最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是**以后永不使用**的，或者是在**最长时间内不再被访问**的页面,这样可以保证获得最低的缺页率。
但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。
### 2. **FIFO** 先进先出置换算法
优先**淘汰最早**进入内存的页面，亦即在内存中驻留时间最久的页面。

Belady异常 = FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象
### 3. **LRU** 最近最久未使用置换算法
每次淘汰的页面是**最近最久未使用**的页面实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自．上次被访问以来所经历的时间t（该算法的实现需要专门的**硬件支持**，虽然算法性能好，但是**实现困难，开销大**）。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。
