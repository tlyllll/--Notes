## 文件权限
- 每个Linux文件具有四种访问权限：
  - 可读(r)、可写(w)、可执行(x)和无权限(-)。

利用`ls -l`命令可以看到某个文件或目录的权限，它以显示数据的第一个字段为准。第一个字段由10个字符组成，如下：
```
    （u）           （o）
  2-4位表示文件   所有者所属组之外
  所有者的权限     的用户的权限
      |   ｜      ｜   ｜
    - r w x r - x r - x
    |       ｜  ｜
第一位表示 5-7位表示文件
文件类型   所有者所属组成员的权限
            （g）


```
以上例子表示这是一个文件(非目录），文件所有者具有读、写和执行的权限，所有者所属组成员和所属组之外的用户具有读和执行的权限而没有写的权限。

2-10位的权限总和有时称为a权限

### 文件权限更改
1. 数字表示
```
   r = 4
   w = 2
   x = 1
   无 = 0

   rwxrwxr-x 
   = ((0b111)(0b111)(0b101))
   = 775

   rwxr-xr-x
   = (0b111)(0b101)(0b101)
   = 755
```
2. 修改命令
- 使用数字
  -  ` chmod 664 test`
  -  将文件test的权限修改为所有者和组成员具有读写的权限，其他人只有读权限
+ 使用文本
  + u：所有者
  + g：组成员
  + o：其他成员
  + a：所有人
  + 权限仍用r、w和x表示
  + 文本表示法不仅可以重新指定权限，也可以在原来权限的基础上增加或减少权限，如下
  +  =：重新制定权限
  + -：对目前的设置减少权限
  + +：对目前的设置增加权限
  + `chmod u+x,g-x,o=x test` 逗号前后没有空格

3. 目录权限

    目录权限的修改和文件权限修改不同，只是四种权限代表的含义如下：

    r：可列出目录中的内容

    w：可在目录中创建、删除和修改文件

    x：可以使用cd命令切换到此目录

    -：没有任何此目录的访问权限

> 注意：目录可以使用通配符"*"来表示目录中的所有文件，如将/test目录中的所有文件的权限设置为任何人都可以读写
`chmod 666 /test/*`

4. 默认权限掩码-----umask
权限掩码有4个八进制的数字组成，现有的权限减掉权限掩码后，即可产生此文件建立时的默认权限。

一般来说，新建文件的默认值是`0666`，新建目录的默认值是`0777`，如果将全线掩码设置为`0002`，则每个新建文件的默认权限为0666-0002=0664，而目录的默认权限则为`775`。可以直接输入umask命令来检查目前的默认权限掩码，或输入"`umask` 权限掩码"来指定默认权限掩码。用`umask`的方式指定默认权限掩码，可以**避免添加访问权限过大**的文件或目录。
# 进程
## 孤儿进程/僵尸进程/守护进程
### 孤儿进程
父进程在子进程推退出之前就结束了自己的生命，此时的子进程叫做孤儿进程。

孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。

孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。

每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。

这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。
因此**孤儿进程并不会有什么危害** 。
### 僵尸进程
一个子进程在其父进程还没有调用wait()或waitpid()的情况下退出。这个子进程就是僵尸进程。

任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是**每个**子进程在结束时都要经过的阶段。

如果子进程在exit()之后，父进程没有来得及处理，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的

如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。
### 守护进程
守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。

很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。
用户使守护进程独立于所有终端是因为，在守护进程从一个终端启动的情况下，这同一个终端可能被其他的用户使用。
例如，用户从一个终端启动守护进程后退出，然后另外一个人也登录到这个终端。
用户不希望后者在使用该终端的过程中，接收到守护进程的任何错误信息。同样，由终端键人的任何信号(例如中断信号)也不应该影响先前在该终端启动的任何守护进程的运行。
虽然让服务器后台运行很容易(只要shell命令行以&结尾即可)，但用户还应该做些工作，让程序本身能够自动进入后台，且不依赖于任何终端。