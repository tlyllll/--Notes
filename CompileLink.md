参考：[leetcode](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vvqvi5/)
[Cherno tutorial](https://github.com/remolaz/TheChernoCppTutorial_Code)

# 编译和链接
## 编译
**主要目的**：将我们编写好的代码最终翻译为机器可执行的*二进制指令*，编译的过程本质上也即是翻译的过程
## 处理过程(`.cpp` -> `ELF`)
**(.i)编译预处理：** 
1. 处理源代码中的预处理指令
+ 引入头文件（`#include`）
+ 处理所有的*条件编译指令*（`#ifdef, #ifndef, #else, #elif, #endif`）
+ 宏（`#define`）
2. 添加行号，保留所有的编译器指令
   
**(.s)编译：**
`.cpp` 源文件翻译成 `.s` 的汇编代码

**(.o)汇编：**
- 将汇编代码` .s` 翻译成机器指令 `.o` 文件
- 一个 `.cpp` 文件只会生成一个 `.o` 文件

**链接：**
汇编生成的**单个**`.o`文件可能由于程序由多个源文件组成而无法执行。

文件 A 中的函数引用了另一个文件 B 中定义的符号或者调用了某个库文件中的函数，这就需要链接处理。

那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成一个可被操作系统加载执行的`ELF` 程序文件。
![](2022-09-19-14-12-35.png)

> 在计算机科学中，是一种用于**二进制文件**、可执行文件、目标代码、共享库和核心转储格式文件的文件格式。是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。

# cpp的静态库和动态库
## 二进制文件
链接二进制文件比链接源代码要快，而且更可取。

二进制文件有时无法用于项目，因此您需要自己构建

下载预编译的二进制文件:根据想要构建的应用程序类型，获取32位或64位二进制文件。

一个库由两个部分组成:
1. 目录：include目录有一堆头文件
2. 库目录：库目录具有库函数的预构建二进制文件

## 静态库
*STATIC* : 
- 意味着库被放在**可执行文件**中【该程序所需要的全部外部调用函数全部拷贝到最终的可执行程序文件中】，并用它编译。在这种情况下，您只需要您的可执行文件，而不需要其他文件。
- 在该程序被执行时，该程序运行时所需要的全部代码都会被装入到该进程的虚拟地址空间中。
- Linux 系统下，静态链接库一般以 `.a` 文件，我们可以将多个 `.o` 文件链接成一个静态链接库。静态链接演示如下：


*DYNAMIC* : 
- 它在**运行时被链接**。动态库可以**动态加载**(有一个名为*load library*的函数将加载动态库)，
- 也可以在午餐时间加载*DLL(动态链接库)*文件。在这种情况下，您的可执行文件**需要存在一个外部文件**，即动态库`dll`
- 在 Linux 系统下，动态链接库一般以 `.so` 文件，我们可以将多个 `.o` 文件链接成一个动态链接库。
- 在程序执行时，当需要调用这部分程序时，操作系统会从将这些动态链或者共享对象进行加载，并将全部内容会被**映射**到该进行运行的虚拟地址的空间。

### 比较
与动态链接相比，静态链接可以产生**更快**的应用程序：
+ 因为在编译期间可以对静态库进行一些优化，
+ 而如果我们有一个需要保持完整的外部动态链接库，不可轻易对外部动态链接库进行修改，则不可能执行这些优化。
+ 可执行程序具备了程序运行的所有内容。 动态链接**节省内存**、**更新方便**，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。（**链接费时**）
+ 
静态链接**浪费空间**，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（**更新困难**）
### 区别
- 静态链接是由**连接器**完成的
- 动态链接最终是由**操作系统**来完成链接的功能，动态链接在不同的操作系统下可能由不同的实现原理，比如在 Linux 系统下，动态链接库通常以 `.so` 文件存在，在windows 下同下，动态链接库一般以 `.dll` 文件存在。

Include可以使用
1.  `""` ：首先在解的相对路径中搜索，然后在编译器路径中搜索
2.  `<>` ：则直接在编译器路径中搜索

因此，要在代码中包含一个库，首先需要添加库的头文件，包含在文件夹include中，然后需要将存在于文件夹库中的库链接到Linker中。你为链接器/通用指定附加库目录，然后在链接器/输入中，在“附加依赖项”中输入库名称

>注意:当你指定库头或库本身的路径时，最好使用相对路径

