<!DOCTYPE html>
<html>
<head>
<title>JavaScript.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="file:///Users/linyiting/Downloads/typora-notion-theme-main/themes/enhanced/notion-light-enhanced.css" type="text/css">
<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<p><img src="./img/2023-02-02-16-08-18.png" alt=""></p>
<h1 id="js">js</h1>
<h2 id="%E5%8E%9F%E5%9E%8B%E9%93%BE">原型链</h2>
<p><img src="./img/2022-12-17-11-28-33.png" alt=""></p>
<ol>
<li>js分为<strong>函数对象</strong>和<strong>普通对象</strong>，每个对象都有<code>__proto__</code>属性，但是只有函数对象才有<code>prototype</code>属性</li>
<li>Object、Function都是js内置的函数, 类似的还有我们常用到的Array、RegExp、Date、Boolean、Number、String</li>
</ol>
<ul>
<li>属性<code>__proto__</code>是一个对象, 它有两个属性，<code>constructor</code>和<code>__proto__</code></li>
</ul>
<pre class="hljs"><code><div>{
    <span class="hljs-attr">__proto__</span>:{
        <span class="hljs-keyword">constructor</span>,
        __proto__
    }
}
</div></code></pre>
<ul>
<li>原型对象prototype有一个默认的constructor属性，用于记录实例是由哪个构造函数创建；</li>
<li>实例对象的<code>__proto__</code> = 实例对象构造函数的<code>prototype</code></li>
<li>这里可以看出三者关系：
<ul>
<li>实例.<strong>proto</strong> === 原型(prototype) ；</li>
<li>原型(prototype).constructor === 构造函数 ；</li>
<li>构造函数.prototype === 原型 ；</li>
</ul>
</li>
</ul>
<h4 id="qnew-object%E5%92%8Cobjectcreate%E7%9A%84%E5%8C%BA%E5%88%AB">Q:{}，new Object()和Object.create()的区别?</h4>
<ol>
<li>{}等价于new Object(), 都继承了Object原型链上(Object.prototype)的属性或者方法，eg：toString()；当创建的对象相同时，可以说 {} 等价于 new Object() 。</li>
<li>Object.create() 是将<strong>创建的对象</strong>继承到原型链上，而<strong>本身没有继承</strong> Object.prototype 的属性和方法。</li>
</ol>
<h2 id="%E7%BB%A7%E6%89%BF">继承</h2>
<h3 id="%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF">原型链继承</h3>
<p><img src="./img/2023-01-10-14-26-26.png" alt="">
核心： 子类.prototype = 父类实例</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>{
   <span class="hljs-keyword">this</span>.isShow = <span class="hljs-literal">true</span>
   <span class="hljs-keyword">this</span>.info = {
       <span class="hljs-attr">name</span>: <span class="hljs-string">"mjy"</span>,
       <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,
   };
}
 
Parent.prototype.getInfo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
   <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.info);
   <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.isShow);
}
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params"></span>) </span>{};
Child.prototype = <span class="hljs-keyword">new</span> Parent();
 
<span class="hljs-keyword">let</span> Child1 = <span class="hljs-keyword">new</span> Child();
Child1.info.gender = <span class="hljs-string">"男"</span>;
Child1.getInfo(); <span class="hljs-comment">// {name: 'mjy', age: 18, gender: '男'} true</span>
 
<span class="hljs-keyword">let</span> child2 = <span class="hljs-keyword">new</span> Child();
child2.isShow = <span class="hljs-literal">false</span>
<span class="hljs-built_in">console</span>.log(child2.info.gender) <span class="hljs-comment">// 男</span>
child2.getInfo(); <span class="hljs-comment">// {name: 'mjy', age: 18, gender: '男'} false</span>
Child1.getInfo(); <span class="hljs-comment">// {name: 'mjy', age: 18, gender: '男'} true</span>
<span class="hljs-comment">//两个子实例修改互不影响</span>
</div></code></pre>
<p>优点：写法方便简洁，容易理解。</p>
<p>缺点：</p>
<ol>
<li>新实例无法向父类构造函数传参。</li>
<li>继承单一。无法实现多继承</li>
<li>子类实例共享了父类构造函数的引用属性（原型上的引用属性是共享的，一个实例修改了引用属性，另一个实例的属性也会被修改！）【理解为继承的是指针，指针不更改，更改指向的东西，那必定会变】</li>
</ol>
<h3 id="%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF">借用构造函数继承</h3>
<p>核心：借用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类</p>
<p><img src="./img/2023-01-10-15-04-03.png" alt=""></p>
<p>使用.call/.apply</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name,like</span>)</span>{
　　Parent.call(<span class="hljs-keyword">this</span>,name);<span class="hljs-comment">//核心，拷贝了父类的实例属性和方法</span>
　　<span class="hljs-keyword">this</span>.like = like;
}
</div></code></pre>
<ol>
<li>只继承了父类构造函数的属性，<strong>没有继承父类原型</strong>的属性。</li>
<li>解决了原型链继承缺点1、2、3。</li>
<li>可以继承多个构造函数属性（call多个）。</li>
<li>在子实例中可向父实例<strong>传参</strong>。</li>
</ol>
<p>缺点：</p>
<ol>
<li>每个新实例都有父类构造函数的副本，臃肿。【也就是说每个实例的父类构造函数都是深拷贝得到的，所以怎么修改都互不影响】</li>
<li>无法实现构造函数的复用。（每次用每次都要重新调用）</li>
<li>只能继承父类构造函数的属性。</li>
</ol>
<h3 id="%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E9%93%BE">组合继承【构造函数+原型链】</h3>
<p><img src="./img/2023-01-10-15-03-16.png" alt=""></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">gender</span>) </span>{
   <span class="hljs-keyword">this</span>.isShow = <span class="hljs-literal">true</span>
   <span class="hljs-keyword">this</span>.info = {
       <span class="hljs-attr">name</span>: <span class="hljs-string">"mjy"</span>,
       <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,
       <span class="hljs-attr">gender</span>: gender
   };
}
 
Parent.prototype.getInfo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
   <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.info);
   <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.isShow);
}
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">gender</span>) </span>{
    Parent.call(<span class="hljs-keyword">this</span>, gender) <span class="hljs-comment">//核心</span>
};
Child.prototype = <span class="hljs-keyword">new</span> Parent();<span class="hljs-comment">//核心</span>
</div></code></pre>
<p>优点：</p>
<ol>
<li>创造子类实例，可以向父类构造函数传参；</li>
<li>不共享父类的引用属性</li>
<li>父类的方法定义在父类的原型对象上，实现方法复用；</li>
</ol>
<p>缺点：
调用了两次父类的构造方法，会存放一份<strong>多余的父类实例属性</strong></p>
<h3 id="%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF">原型式继承</h3>
<p>核心：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。</p>
<p>类似于复制一个对象，用函数来包装，不需要单独创建构造函数。</p>
<p><img src="./img/2023-01-10-15-28-38.png" alt=""></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObject</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fun</span>(<span class="hljs-params"></span>) </span>{}
  Fun.prototype = obj
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fun()
}
 
<span class="hljs-keyword">let</span> person = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">'mjy'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,
  <span class="hljs-attr">hoby</span>: [<span class="hljs-string">'唱'</span>, <span class="hljs-string">'跳'</span>],
  showName() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'my name is:'</span>, <span class="hljs-keyword">this</span>.name)
  }
}
 
<span class="hljs-keyword">let</span> child1 = createObject(person)
child1.name = <span class="hljs-string">'xxxy'</span>
child1.hoby.push(<span class="hljs-string">'rap'</span>)
<span class="hljs-keyword">let</span> child2 = createObject(person)
 
<span class="hljs-built_in">console</span>.log(child1)
<span class="hljs-built_in">console</span>.log(child2)
<span class="hljs-built_in">console</span>.log(person.hoby) <span class="hljs-comment">// ['唱', '跳', 'rap']</span>
<span class="hljs-comment">//也可以</span>
<span class="hljs-keyword">var</span> sup = <span class="hljs-keyword">new</span> Person()
<span class="hljs-keyword">var</span> sup = content(sup)
</div></code></pre>
<p>缺点：</p>
<ol>
<li>属性中包含的引用值始终会在相关对象间共享</li>
<li>子类实例不能向父类传参</li>
</ol>
<h3 id="%E5%AF%84%E7%94%9F">寄生</h3>
<p>核心， 在原型式基础上套了个壳子</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectCopy</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fun</span>(<span class="hljs-params"></span>) </span>{ };
  Fun.prototype = obj;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fun();
}
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnother</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-keyword">let</span> clone = objectCopy(obj);
  clone.showName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'my name is：'</span>, <span class="hljs-keyword">this</span>.name);
  };
  <span class="hljs-keyword">return</span> clone;
}
 
<span class="hljs-keyword">let</span> person = {
     <span class="hljs-attr">name</span>: <span class="hljs-string">"mjy"</span>,
     <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,
     <span class="hljs-attr">hoby</span>: [<span class="hljs-string">'唱'</span>, <span class="hljs-string">'跳'</span>]
}
 
<span class="hljs-keyword">let</span> child1 = createAnother(person);
child1.hoby.push(<span class="hljs-string">"rap"</span>);
<span class="hljs-built_in">console</span>.log(child1.hoby); <span class="hljs-comment">// ['唱', '跳', 'rap']</span>
child1.showName(); <span class="hljs-comment">// my name is： mjy</span>
 
<span class="hljs-keyword">let</span> child2 = createAnother(person);
<span class="hljs-built_in">console</span>.log(child2.hoby); <span class="hljs-comment">// ['唱', '跳', 'rap']</span>
</div></code></pre>
<h3 id="%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88">寄生组合</h3>
<p>寄生组合继承就是为了降低父类构造函数的开销而实现的。</p>
<p><img src="./img/2023-01-10-16-50-43.png" alt=""></p>
<pre class="hljs"><code><div><span class="hljs-comment">//作用：让child.prototype的__proto__=Parent.prototype</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectCopy</span>(<span class="hljs-params">obj</span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fun</span>(<span class="hljs-params"></span>) </span>{ };
  Fun.prototype = obj;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fun();
}
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">child, parent</span>) </span>{
  <span class="hljs-keyword">let</span> prototype = objectCopy(parent.prototype);
  prototype.constructor = child;
  Child.prototype = prototype;
}
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>) </span>{
  <span class="hljs-keyword">this</span>.name = name;
  <span class="hljs-keyword">this</span>.hoby = [<span class="hljs-string">'唱'</span>, <span class="hljs-string">'跳'</span>]
}
 
Parent.prototype.showName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'my name is：'</span>, <span class="hljs-keyword">this</span>.name);
}
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name, age</span>) </span>{
  Parent.call(<span class="hljs-keyword">this</span>, name); <span class="hljs-comment">//作用：可以给父类传参 但只能继承父类构造函数的属性。</span>
  <span class="hljs-keyword">this</span>.age = age;
}
 
inheritPrototype(Child, Parent);
Child.prototype.showAge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'my age is：'</span>, <span class="hljs-keyword">this</span>.age);
}
 
<span class="hljs-keyword">let</span> child1 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">"mjy"</span>, <span class="hljs-number">18</span>);
child1.showAge(); <span class="hljs-comment">// 18</span>
child1.showName(); <span class="hljs-comment">// mjy</span>
child1.hoby.push(<span class="hljs-string">"rap"</span>);
<span class="hljs-built_in">console</span>.log(child1.hoby); <span class="hljs-comment">// ['唱', '跳', 'rap']</span>
 
<span class="hljs-keyword">let</span> child2 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">"yl"</span>, <span class="hljs-number">18</span>);
child2.showAge(); <span class="hljs-comment">// 18</span>
child2.showName(); <span class="hljs-comment">// yl</span>
<span class="hljs-built_in">console</span>.log(child2.hoby); <span class="hljs-comment">// ['唱', '跳']</span>
</div></code></pre>
<p>优点：</p>
<ol>
<li>高效率只调用一次父构造函数，</li>
<li>并且因此避免了在子原型上面创建不必要，多余的属性。</li>
<li>与此同时，原型链还能保持不变；</li>
</ol>
<h3 id="class%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BFes6">class实现继承[ES6]</h3>
<pre class="hljs"><code><div><span class="hljs-comment">//父类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>{
<span class="hljs-comment">//构造函数</span>
  <span class="hljs-keyword">constructor</span>(name, dept) {
    <span class="hljs-keyword">this</span>.name = name
    <span class="hljs-keyword">this</span>.dept = dept
  }
  <span class="hljs-comment">//静态方法</span>
  <span class="hljs-comment">//static只能修饰class的方法，而不能修饰属性。静态方法不在实例化对象的方法中，里面不能有this。</span>
  <span class="hljs-comment">//通过实例出来的对象可以，调用构造函数上面的方法。</span>
  <span class="hljs-keyword">static</span> fun() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'static'</span>)
  }
  getName() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)
  }
}

<span class="hljs-comment">//子类</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span> </span>{
  <span class="hljs-keyword">constructor</span>(name, dept, reports) {
    <span class="hljs-keyword">super</span>(name, dept)
    <span class="hljs-keyword">this</span>.reports = reports
  }
  FunctionName() {
    <span class="hljs-comment">/*写自己的逻辑*/</span>
  }
}
</div></code></pre>
<p>特点：</p>
<ol>
<li>函数声明具有可提升性，虽然类本质上是函数，但是类的声明却不可提升，也就是说你一定要先声明类，才能创建对象。</li>
<li>无法重写，无法重复声明</li>
<li>不需要 function 关键字。</li>
<li>必须使用new关键字。</li>
</ol>
<h2 id="%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">基本数据类型</h2>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Object</li>
<li>Null: 一种特殊的Object = 0 = false</li>
<li>Undefined: 未定义/未初始化 = NaN = false</li>
<li>Symbol(ES6): <s>唯一的姐</s> 唯一的值 就算参数一样也是两个东西，可以用description输出参数</li>
<li>BigInt(ES10)</li>
</ul>
<h3 id="%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD">类型判断</h3>
<ul>
<li>typeof: Number/String/Boolean/undefined/Object/Symbol
<ul>
<li>不能判断（Array, Error, null）-&gt; Object</li>
</ul>
</li>
<li>instanceof: 判断数据是否是某个对象实例。是不是原型链上的</li>
<li>Object.prototype.toString.call()</li>
</ul>
<h3 id="%E7%B2%BE%E5%BA%A6%E9%97%AE%E9%A2%98">精度问题</h3>
<p>javascript的浮点数运算就是采用了<strong>IEEE 754的标准</strong>。</p>
<p>IEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。</p>
<p>其中javascript采用的是 <strong>双精度（64位）浮点运算规则</strong>。
<img src="./img/2022-12-24-12-38-55.png" style="zoom:100%; margin-left: 14%" />
IEEE754存储和运算规则：</p>
<table>
<thead>
<tr>
<th>数符</th>
<th>阶码</th>
<th>尾数</th>
</tr>
</thead>
<tbody>
<tr>
<td>sign</td>
<td>exponent</td>
<td>fraction</td>
</tr>
<tr>
<td>正负的符号位， 0表示正数，1表示负数</td>
<td>指数偏移值.指数值加上某个固定的值。固定值为：2^e - 1，其中e为存储指数的长度，比如32位的是8，64位的为11</td>
<td>可以理解为小数点部分。超出的部分自动进一舍零</td>
</tr>
</tbody>
</table>
<p>一个浮点数在计算机中表示为：</p>
<p>Value = sign x exponent x function</p>
<ul>
<li>0.1 + 0.2 为什么出现精度失真呢？
<ul>
<li>十进制的0.1和0.2会被转换成二进制的，但是由于浮点数用二进制表示时是无穷的</li>
<li><code>0.1 -&gt; 0.0001 1001 1001 1001...(1100循环)</code></li>
<li><code>0.2 -&gt; 0.0011 0011 0011 0011...(0011循环)</code></li>
<li>64 位双精度浮点数的小数部分最多支持53位二进制位</li>
<li>相加之后得到二进制为<code>0.0100110011001100110011001100110011001100110011001100</code></li>
<li>点数小数位的限制而截断的二进制数字，再转换为十进制，就成了0.30000000000000004。所以在进行算术计算时会产生误差。</li>
</ul>
</li>
</ul>
<p>解决方式：</p>
<ol>
<li>toFixed</li>
</ol>
<ul>
<li>但是还是会有不精准的问题</li>
</ul>
<pre class="hljs"><code><div>  <span class="hljs-number">1.35</span>.toFixed(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1.4 正确</span>
  <span class="hljs-number">1.335</span>.toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// 1.33  错误</span>
  <span class="hljs-number">1.3335</span>.toFixed(<span class="hljs-number">3</span>) <span class="hljs-comment">// 1.333 错误</span>
  <span class="hljs-number">1.33335</span>.toFixed(<span class="hljs-number">4</span>) <span class="hljs-comment">// 1.3334 正确</span>
  <span class="hljs-number">1.333335</span>.toFixed(<span class="hljs-number">5</span>)  <span class="hljs-comment">// 1.33333 错误</span>
  <span class="hljs-number">1.3333335</span>.toFixed(<span class="hljs-number">6</span>) <span class="hljs-comment">// 1.333333 错误</span>
</div></code></pre>
<ol start="2">
<li>小数转化为整数再进行计算<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">roundFractional</span>(<span class="hljs-params">x, n</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round(x * <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, n)) / <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">10</span>, n);
}
</div></code></pre>
</li>
<li>第三方库【bignumber.js/decimal.js/big.js】</li>
</ol>
<h2 id="%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F">创建变量</h2>
<h3 id="var-let-const">var/ let /const</h3>
<ul>
<li>var: 有<strong>变量提升</strong></li>
<li>let: 不能重复定义，可以修改值</li>
<li>const: 不能重复定义，不能修改值（除了数组和对象）</li>
</ul>
<h3 id="%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87">变量提升/ 函数提升</h3>
<pre class="hljs"><code><div>   <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// undefined</span>
   <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>
   <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">//1</span>
</div></code></pre>
<p>实际运行顺序</p>
<pre class="hljs"><code><div>   <span class="hljs-keyword">var</span> a
   <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// undefined</span>
   a = <span class="hljs-number">1</span>
   <span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">//1</span>
</div></code></pre>
<p>声明自动上提 = 变量提升</p>
<p>函数也一样</p>
<p>变量提升 &gt; 函数提升</p>
<h3 id="%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D">深拷贝/浅拷贝</h3>
<h5 id="%E6%B5%85%E6%8B%B7%E8%B4%9D">浅拷贝：</h5>
<p>创造了一个引用/共享内存</p>
<p>实现方法：</p>
<ol>
<li>
<p><code>Object.assign()</code>: 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign() 进行的是浅拷贝，<strong>拷贝的是对象的属性的引用，而不是对象本身</strong>。当object<strong>只有一层</strong>的时候，是<strong>深拷贝</strong></p>
</li>
<li>
<p>展开运算符<code>...</code>: 与 Object.assign ()的功能相同</p>
<ol>
<li>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> obj2= {... obj1}
</div></code></pre>
</li>
</ol>
</li>
</ol>
<h5 id="%E6%B7%B1%E6%8B%B7%E8%B4%9D">深拷贝：</h5>
<p>创造了一个一摸一样的对象</p>
<p>实现方法:</p>
<ol>
<li>
<p>对象只有一层的话可以使用上面的：Object.assign()函数</p>
</li>
<li>
<p>使用JSON</p>
<ol>
<li>
<p>不支支持 <strong>Date、正则、undefined、函数</strong></p>
</li>
<li>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> obj1 = { <span class="hljs-attr">body</span>: { <span class="hljs-attr">a</span>: <span class="hljs-number">10</span> } };
<span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj1));
obj2.body.a = <span class="hljs-number">20</span>;
<span class="hljs-built_in">console</span>.log(obj1);
<span class="hljs-comment">// { body: { a: 10 } } &lt;-- 沒被改到</span>
<span class="hljs-built_in">console</span>.log(obj2);
<span class="hljs-comment">// { body: { a: 20 } }</span>
<span class="hljs-built_in">console</span>.log(obj1 === obj2);
<span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(obj1.body === obj2.body);
<span class="hljs-comment">// false</span>
</div></code></pre>
</li>
</ol>
</li>
<li>
<p>使用<code>Object.create()</code>方法</p>
<ol>
<li>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> newObj = <span class="hljs-built_in">Object</span>.create(oldObj)
</div></code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB">==和===的区别</h2>
<ul>
<li><code>==</code> <strong>值</strong>相等。会先做类型转换，之后再判断值大小</li>
<li><code>===</code> <strong>值</strong>和<strong>类型</strong>都相等。</li>
</ul>
<h2 id="%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6">执行机制</h2>
<p>JavaScript 的执行分为：解释和执行两个阶段</p>
<p><strong>解释阶段：</strong>
- 词法分析
- 语法分析
- 作用域规则确定</p>
<p><strong>执行阶段</strong>：
- 创建执行上下文
- 执行函数代码
- 垃圾回收</p>
<p>javascript是一门<strong>单线程</strong>语言，任务分为同步和异步</p>
 <img src="./img/2022-12-09-15-16-54.png" style="zoom:40%;" />
<ul>
<li>当指定的事情完成时，Event Table会将这个函数移入Event Queue。</li>
<li>主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。</li>
<li>上述过程会不断重复，也就是常说的Event Loop(事件循环)。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">let</span> data = [];
$.ajax({
    <span class="hljs-attr">url</span>:www.javascript.com,
    <span class="hljs-attr">data</span>:data,
    <span class="hljs-attr">success</span>:<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'发送成功!'</span>);
    }
})
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'代码执行结束'</span>);
</div></code></pre>
<ul>
<li>ajax进入Event Table， 注册回调函数<code>success</code></li>
<li>执行<code>console.log('代码执行结束')</code>。</li>
<li>ajax事件完成后，<code>success</code>进入<strong>Event Queue</strong></li>
<li>主线程从<strong>Event Queue</strong>读取回调函数<code>success</code>并执行。</li>
</ul>
<h3 id="%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">回调函数</h3>
<p>函数 B 作为参数（函数引用）传递到另一个函数 A 中，并且这个函数 A 执行函数 B。我们就说函数 B 叫做回调函数。</p>
<p>当一个函数作为参数传入另一个参数中，并且它不会立即执行，只有当满足一定条件后该函数才可以执行，这种函数就称为回调函数。</p>
<p><strong>回调地狱：</strong></p>
<ul>
<li>回调地狱就是为是实现代码顺序执行而出现的一种操作，它会造成我们的代码可读性非常差，后期不好维护</li>
<li>回调函数中嵌套回调函数的情况就叫做回调地狱</li>
</ul>
<p><strong>解决方式：</strong></p>
<ul>
<li>promise</li>
<li>async/await</li>
</ul>
<h3 id="settimeout">setTimeout</h3>
<p><strong>异步</strong> 可以延时执行</p>
<pre class="hljs"><code><div>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    task()
},<span class="hljs-number">3000</span>)

sleep(<span class="hljs-number">10000000</span>)
</div></code></pre>
<p>此时task的时间远远超过三秒：</p>
<ul>
<li>task() -&gt; 进入Event Table 并注册，开始计时</li>
<li>执行sleep()</li>
<li>3s结束，task()进入Event Queue， 但要等sleep先完成</li>
<li>sleep()执行完，task()进入主线程执行</li>
</ul>
<blockquote>
<p>**setTimeout(fn,0)**的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行</p>
</blockquote>
<h3 id="setinterval">setInterval</h3>
<p>和<code>setTimeout</code>很像，不过<code>setInterval</code>这个是<strong>循环执行</strong></p>
<p><code>setInterval(fn,ms)</code>来说，我们已经知道不是每过ms秒会执行一次fn，而是每过ms秒，会有fn进入<strong>Event Queue</strong>。</p>
<p>如果<code>fn</code>执行时间超过了延迟时间<code>ms</code>，那么就完全看不出来有时间间隔了</p>
<h3 id="promisees6">Promise(ES6)</h3>
<p>所谓Promise对象，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>
<p>Promise 本身是同步的立即执行函数， 当在 executor 中执行 resolve 或者 reject 的时候, 此时是异步操作， 会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 中存放的方法执行。</p>
<p><strong>特点：</strong></p>
<ul>
<li>对象的状态不受外界影响。
<ul>
<li>有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）</li>
<li>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态</li>
</ul>
</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。
<ul>
<li><code>pending</code>-&gt;<code>fulfilled</code></li>
<li><code>pending</code>-&gt;<code>rejected</code></li>
<li>只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）</li>
</ul>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>无法中途取消</li>
<li>如果不设置回调函数，内部的错误不会反应到外部</li>
<li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<h4 id="promise-%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%E9%A2%98">Promise 相关代码题</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)
  resolve()
}).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)
    resolve()
  }).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)
  })
}).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)
})
<span class="hljs-comment">//1243</span>
</div></code></pre>
<p><strong>关键点：</strong></p>
<ol>
<li>promise.then(onFulfilled, onRejected)</li>
<li>.then可以在同一个 promise 上多次调用。
<ol>
<li>第一个 then() 方法调用后，会返回一个新的 Promise。</li>
<li>这样做的目的就是为了保持链式调用，而且 then() 方法内的 onFulfilled 回调会等待 Promise 状态修改之后才会调用。</li>
</ol>
</li>
</ol>
<h3 id="%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1">宏任务/微任务</h3>
<ul>
<li>macro-task(宏任务)：包括<strong>整体代码</strong>script，setTimeout，setInterval</li>
<li>micro-task(微任务)：Promise，process.nextTick</li>
</ul>
<img src="./img/2022-12-09-16-07-15.png" style="zoom:33%;" />
<h3 id="asyncawait">async/await</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testAsync</span>(<span class="hljs-params"></span>)</span>{
   <span class="hljs-keyword">await</span> getJSON();  
   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'数据拿到了'</span>);
}
</div></code></pre>
<ol>
<li><code>await</code> 后面的代码放在 async 创建的那个 <code>Promise</code> 里面去执行;</li>
<li><code>await</code> 下面的代码放到前一个 创建的 Promise 对象的 <code>.then</code> 里面去执行。</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>
    <span class="hljs-keyword">let</span> c = <span class="hljs-number">1</span>
    <span class="hljs-keyword">await</span> getContent()
    <span class="hljs-keyword">let</span> d = <span class="hljs-number">3</span>
    <span class="hljs-keyword">await</span> getPromise()
    <span class="hljs-keyword">let</span> e = <span class="hljs-number">4</span>
    <span class="hljs-keyword">await</span> getAsyncContent()
    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>
}
<span class="hljs-comment">//相当于</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
        <span class="hljs-keyword">let</span> a = <span class="hljs-number">2</span>
        <span class="hljs-keyword">let</span> c = <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> getContent()
    })
        .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-keyword">let</span> d = <span class="hljs-number">3</span>
            <span class="hljs-keyword">return</span> getPromise()
        })
        .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-keyword">let</span> e = <span class="hljs-number">4</span>
            <span class="hljs-keyword">return</span> getAsyncContent()
        })
        .then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>
        })
}
</div></code></pre>
<p><a href="https://juejin.cn/post/7122071393495154701">好文</a></p>
<h2 id="this">this</h2>
<p><strong>执行上下文</strong>最明显的就是 this 的指向是<strong>执行时</strong>确定的</p>
<p><strong>全局使用时：</strong></p>
<ul>
<li>this 总是指称为窗口（在 Node.js 中，全局对象是 global 。）</li>
<li>严格模式中：普通函数中的 this 绑定到 undefined</li>
</ul>
<img src="./img/2022-12-13-13-42-22.png" style="zoom:40%;" />
<p><strong>在函数中：</strong>
函数可以大致分为在全局中声明的<strong>一般函数</strong>和在<strong>对象中声明的方法</strong>。</p>
<ul>
<li><strong>一般函数</strong>：指向窗口[窗口对象中的函数]</li>
<li><strong>对象中声明的方法</strong>：所有函数都在对象内部。this 指的是当前正在执行该函数的对象</li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>在函数中/单独 -&gt;全局对象</li>
<li>在对象中的函数中 -&gt;对象</li>
<li>this 指的是当前正在执行该函数的对象</li>
</ul>
<h3 id="%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">普通函数和箭头函数</h3>
<p>最大的区别在于 this 的指向问题：</p>
<ul>
<li>
<p>箭头函数没有自己的 this</p>
</li>
<li>
<p>箭头函数<strong>不能用 new</strong>来创建构造函数的实例，普通函数可以（</p>
<ul>
<li>因为箭头函数创建的时候程序不会为它创建 construct 方法，也就是没有构造能力，用完就丢掉了，</li>
<li>不像普通函数重复利用，因此也不需要构造函数原型，也就是不会自动生成 prototype 属性）</li>
</ul>
</li>
<li>
<p>程序<strong>不会</strong>给箭头函数<strong>创建 arguments 对象</strong></p>
</li>
<li>
<p>箭头函数中的 this 指向的是<strong>紧紧包裹箭头函数的那个对象</strong>（<strong>定义时</strong>决定的）。</p>
<ul>
<li>普通函数中的 this 是动态的，</li>
</ul>
</li>
<li>
<p>箭头函数不能通过 bind、call、apply 来改变 this 的值，但依然可以调用这几个方法（只是 this 的值不受这几个方法控制）</p>
</li>
</ul>
<h4 id="%E5%86%99%E6%B3%95">写法</h4>
<pre class="hljs"><code><div><span class="hljs-comment">// 普通函数</span>
<span class="hljs-keyword">let</span> sum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>{
	<span class="hljs-keyword">return</span> a + b;
}
<span class="hljs-comment">// 箭头函数</span>
<span class="hljs-keyword">let</span> sum1 = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
	<span class="hljs-keyword">return</span> a + b;
}
<span class="hljs-comment">//如果只有一个参数，那也可以不用括号。</span>
<span class="hljs-comment">// 有效</span>
<span class="hljs-keyword">let</span> sum = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> {
	<span class="hljs-keyword">return</span> x;
};
<span class="hljs-comment">// 有效</span>
<span class="hljs-keyword">let</span> sum1 = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> {
	<span class="hljs-keyword">return</span> x;
};
<span class="hljs-comment">// 没有参数需要括号</span>
<span class="hljs-keyword">let</span> sum2 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
};
<span class="hljs-comment">// 有多个参数需要括号</span>
<span class="hljs-keyword">let</span> sum3 = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
	<span class="hljs-keyword">return</span> a + b;
};
<span class="hljs-comment">//箭头函数也可以不用大括号，但这样会改变函数的行为。使用大括号就说明包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样。</span>
<span class="hljs-comment">// 有效</span>
<span class="hljs-keyword">let</span> sum = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> {
	<span class="hljs-keyword">return</span> a + b;
};
<span class="hljs-comment">// 有效</span>
<span class="hljs-keyword">let</span> sum1 = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b; <span class="hljs-comment">// 相当于 return a + b;</span>
<span class="hljs-comment">// 无效的写法</span>
<span class="hljs-keyword">let</span> sum2 = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> <span class="hljs-keyword">return</span> a + b;

<span class="hljs-comment">//箭头函数简洁的语法非常适合嵌入函数的场景：</span>
<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
arr.map(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val * <span class="hljs-number">2</span>); <span class="hljs-comment">// [2, 4, 6, 8, 10]</span>

</div></code></pre>
<h3 id="callapplybind">call()/apply()/bind()</h3>
<ul>
<li>第一个参数都是 this 要指向的对象</li>
<li>都是改变 this 指向的；</li>
<li>都可以利用后续参数传参；</li>
</ul>
<p><strong>call()<strong>和</strong>apply()<strong>相似，都会</strong>直接调用</strong></p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> example = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c</span>) </span>{
  <span class="hljs-keyword">return</span> a + b + c;
};
example(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
example.call(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">//一次放置</span>
example.apply(<span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]); <span class="hljs-comment">//两个参数，第二个是数组</span>
</div></code></pre>
<ul>
<li>当你想应用多个参数，但你想将它们作为<strong>变量</strong>而不是常量应用时，可以使用<code>apply()</code>。</li>
</ul>
<p><strong>bind()<strong>只改变函数指向的this，并</strong>没有调用</strong></p>
<ul>
<li>你定义了this然后复制那个函数来创建一个新函数并返回它</li>
</ul>
<h3 id="%E6%80%BB%E7%BB%93">总结</h3>
<p>this指向优先级</p>
<img src="./img/2022-12-13-13-54-44.png" style="zoom:35%;" />
<h2 id="scope%E4%BD%9C%E7%94%A8%E5%9F%9F">scope作用域</h2>
<p>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域</p>
<p>执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。</p>
<h3 id="%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F"><strong>全局作用域和函数作用域</strong></h3>
<p>在代码中任何地方都能访问到的对象拥有<strong>全局作用域</strong>，一般来说以下几种情形拥有全局作用域：</p>
<ul>
<li>
<p>最外层函数</p>
</li>
<li>
<p>在最外层函数外面定义的变量拥有全局作用域</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> outVariable = <span class="hljs-string">"我是最外层变量"</span>; <span class="hljs-comment">//最外层变量</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outFun</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-comment">//最外层函数</span>
    <span class="hljs-keyword">var</span> inVariable = <span class="hljs-string">"内层变量"</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFun</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">//内层函数</span>
        <span class="hljs-built_in">console</span>.log(inVariable);
    }
    innerFun();
}
<span class="hljs-built_in">console</span>.log(outVariable); <span class="hljs-comment">//我是最外层变量</span>
outFun(); <span class="hljs-comment">//内层变量</span>
<span class="hljs-built_in">console</span>.log(inVariable); <span class="hljs-comment">//inVariable is not defined</span>
innerFun(); <span class="hljs-comment">//innerFun is not defined</span>
</div></code></pre>
</li>
<li>
<p>所有<strong>末定义直接赋值</strong>的变量<strong>自动声明为拥有全局作用域</strong></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outFun2</span>(<span class="hljs-params"></span>) </span>{
    variable = <span class="hljs-string">"未定义直接赋值的变量"</span>;
    <span class="hljs-keyword">var</span> inVariable2 = <span class="hljs-string">"内层变量2"</span>;
}
outFun2(); <span class="hljs-comment">//要先执行这个函数，否则根本不知道里面是啥</span>
<span class="hljs-built_in">console</span>.log(variable); <span class="hljs-comment">//未定义直接赋值的变量</span>
<span class="hljs-built_in">console</span>.log(inVariable2); <span class="hljs-comment">//inVariable2 is not defined</span>
</div></code></pre>
</li>
<li>
<p>所有 window 对象的属性拥有全局作用域</p>
</li>
</ul>
<p><strong>函数作用域</strong>,是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。</p>
<p>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。我们看个例子，用泡泡来比喻作用域可能好理解一点：</p>
<img src="./img/2022-12-15-16-02-33.png" style="zoom:67%;" />
<p>块语句（大括号“｛｝”中间的语句不像函数，它们不会创建一个新的作用域。</p>
<ul>
<li>if</li>
<li>switch 条件语句</li>
<li>for 和 while 循环语句</li>
</ul>
<h3 id="%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F">块级作用域</h3>
<p>块级作用域可通过新增命令 <code>let</code> 和 <code>const</code> 声明</p>
<p>所声明的变量在指定块的<strong>作用域外无法</strong>被访问</p>
<p><strong>创建：</strong></p>
<ul>
<li>在一个函数内部</li>
<li>在一个代码块（由一对花括号<code>{}</code>包裹）内部(if/switch)</li>
</ul>
<p>因为<code>let</code> 和 <code>const</code>没有变量提升+花括号<code>{}</code>内是块级作用域</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getValue</span>(<span class="hljs-params">condition</span>) </span>{
    <span class="hljs-keyword">if</span> (condition) {
        <span class="hljs-keyword">let</span> value = <span class="hljs-string">"blue"</span>;
        <span class="hljs-keyword">return</span> value;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// value 在此处不可用</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
    <span class="hljs-comment">// value 在此处不可用</span>
}
</div></code></pre>
<h3 id="%E9%97%AD%E5%8C%85">闭包</h3>
<p>能在外部访问到内部信息</p>
<p><strong>优点</strong>：变量长期驻扎在内存中，不会被内存回收机制回收，即延长变量的生命周期；</p>
<p><strong>缺点</strong>：大量使用闭包，造成内存占用空间增大，有内存泄露的风险</p>
<h4 id="%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2">如何避免内存泄露</h4>
<ol>
<li>在退出函数之前，将不使用的局部变量赋值为null;</li>
<li>避免变量的循环赋值和引用。</li>
</ol>
<h4 id="%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">常用的应用场景</h4>
<h5 id="%E6%9F%AF%E9%87%8C%E5%8C%96%E5%87%BD%E6%95%B0">柯里化函数</h5>
<pre class="hljs"><code><div><span class="hljs-comment">//普通函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArea</span>(<span class="hljs-params">w,h</span>)</span>{
    <span class="hljs-keyword">return</span> w * h;
}
<span class="hljs-keyword">const</span> area1 = getArea(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);
<span class="hljs-keyword">const</span> area2 = getArea(<span class="hljs-number">10</span>,<span class="hljs-number">30</span>);
<span class="hljs-keyword">const</span> area3 = getArea(<span class="hljs-number">10</span>,<span class="hljs-number">40</span>);

<span class="hljs-comment">//柯里化函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArea</span>(<span class="hljs-params">w</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">h</span>)</span>{
        <span class="hljs-keyword">return</span> w * h;
    }
}
<span class="hljs-keyword">const</span> getTenArea = getArea(<span class="hljs-number">10</span>); <span class="hljs-comment">//return 10*h</span>

<span class="hljs-keyword">const</span> area1 = getTenArea(<span class="hljs-number">20</span>); <span class="hljs-comment">//200</span>
<span class="hljs-keyword">const</span> area2 = getTenArea(<span class="hljs-number">30</span>); <span class="hljs-comment">//300</span>
<span class="hljs-keyword">const</span> area3 = getTenArea(<span class="hljs-number">40</span>); <span class="hljs-comment">//400</span>
</div></code></pre>
<h5 id="%E9%80%9A%E8%BF%87%E9%97%AD%E5%8C%85%E5%AE%9E%E7%8E%B0%E5%8F%98%E9%87%8F%E6%96%B9%E6%B3%95%E7%9A%84%E7%A7%81%E6%9C%89%E5%8C%96%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85">通过闭包实现变量/方法的私有化/函数封装</h5>
<p>例如封装一个防抖函数/log函数</p>
<p>下面这个例子有点像log</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">funOne</span>(<span class="hljs-params">i</span>)</span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getTwo</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'参数：'</span>, i)
    }
    <span class="hljs-keyword">return</span> getTwo;
}
<span class="hljs-keyword">const</span> fa = funOne(<span class="hljs-number">100</span>); 
<span class="hljs-keyword">const</span> fb = funOne(<span class="hljs-number">200</span>); 
<span class="hljs-keyword">const</span> fc = funOne(<span class="hljs-number">300</span>); 
</div></code></pre>
<h5 id="%E5%8C%BF%E5%90%8D%E8%87%AA%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0">匿名自执行函数</h5>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> funOne = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        num++;
        <span class="hljs-keyword">return</span> num;
    }
})()

<span class="hljs-built_in">console</span>.log(funOne());   <span class="hljs-comment">// 1</span>
<span class="hljs-built_in">console</span>.log(funOne());   <span class="hljs-comment">// 2</span>
<span class="hljs-built_in">console</span>.log(funOne());   <span class="hljs-comment">// 3 </span>
</div></code></pre>
<h5 id="%E7%BC%93%E5%AD%98%E4%B8%80%E4%BA%9B%E7%BB%93%E6%9E%9C">缓存一些结果</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parent</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> list = [];
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">son</span>(<span class="hljs-params">i</span>)</span>{
        list.push(i);
    }
    <span class="hljs-keyword">return</span> son;
}

<span class="hljs-keyword">const</span> fn = parent();

fn(<span class="hljs-number">1</span>);
fn(<span class="hljs-number">2</span>);
fn(<span class="hljs-number">3</span>);
</div></code></pre>
<h3 id="%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE">作用域链</h3>
<p>自由变量 = 当前作用域没有定义的变量</p>
<p>作用域链 = 自由变量向上级作用域一层一层寻找的路</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> x = <span class="hljs-number">10</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(x);
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">show</span>(<span class="hljs-params">f</span>) </span>{
    <span class="hljs-keyword">var</span> x = <span class="hljs-number">20</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        f(); <span class="hljs-comment">//10，而不是20</span>
    })();
}
show(fn);
</div></code></pre>
<p>在 fn 函数中，取自由变量 x 的值时，要到哪个作用域中取？</p>
<ul>
<li>要到<strong>创建</strong> fn 函数的那个作用域中取，无论 fn 函数将在哪里调用。</li>
</ul>
<h3 id="%E5%BB%B6%E9%95%BF%E4%BD%9C%E7%94%A8%E5%9F%9F">延长作用域</h3>
<p><strong>1. try...catch</strong></p>
<p>对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p>
<p><strong>2. with</strong></p>
<p>对 with 语句来说，会将指定的对象添加到作用域链中。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildUrl</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> qs = <span class="hljs-string">"?debug=true"</span>; 
    <span class="hljs-keyword">with</span>(location){
        <span class="hljs-keyword">var</span> url = href + qs;
        <span class="hljs-comment">//这里的href可以在location里查找</span>
    }
    <span class="hljs-keyword">return</span> url;
}
</div></code></pre>
<h2 id="%E9%98%B2%E6%8A%96">防抖</h2>
<ul>
<li>只执行最后一次。防抖是规定时间内发生抖动时不执行后续操作。</li>
<li>函数防抖就是法师发技能的时候要读条，技能读条没完再按技能就会重新读条。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myDebounce</span>(<span class="hljs-params">fn,wait = <span class="hljs-number">1000</span></span>)</span>{
    <span class="hljs-comment">//创建一个标记 用来放定时器的返回值</span>
    <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">// 每当用户输入的时候把钱一个setTimeout clear掉</span>
        clearTimeout(timeout);
        timeout = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
            <span class="hljs-comment">// 然后又创建一个新的setTimeout</span>
            <span class="hljs-comment">// 这样就能保证输入字符后的interval间隔内如果还有字符输入的话</span>
            <span class="hljs-comment">// 就不会执行fn</span>
            fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
        }, <span class="hljs-number">500</span>);
    }
}
</div></code></pre>
<h2 id="%E8%8A%82%E6%B5%81">节流</h2>
<ul>
<li>控制执行次数。
<ul>
<li>e.g. 滚动条拉到合适的位置了，过 5ms，再进行改变。</li>
</ul>
</li>
<li>函数节流就是fps游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹。</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn,delay</span>)</span>{
    <span class="hljs-comment">//创建一个标记 用来放定时器的返回值</span>
    <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">if</span>(!timer) {
            timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{
                fn.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
                timer = <span class="hljs-literal">null</span>;
            }, delay);
        }
    }
}
</div></code></pre>
<h2 id="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</h2>
<h3 id="set%E9%9B%86%E5%90%88">Set集合</h3>
<h3 id="map">Map</h3>
<p>having和where区别
exist 和 in的区别</p>
<h3 id="weakmap">WeakMap</h3>
<p>有点像c++中的weak_pointer</p>
<ul>
<li>不影响引用计数</li>
<li>无法遍历</li>
<li>键的类型必须是引用对象【当外部对此引用对象的引用计数为0时自动被垃圾回收】</li>
</ul>
<h2 id="%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C">数组操作</h2>
<h3 id="for">for</h3>
<ol>
<li>
<p>for..of(ES6):</p>
<ul>
<li>循环用来<strong>遍历数组</strong></li>
<li>允许遍历获得<strong>键值</strong></li>
<li>只遍历当前对象 ；</li>
<li>返回数组下标对应的属性值</li>
<li>对于普通对象，没有部署原生的 <code>iterator</code> 接口，直接使用 for...of 会报错
<ul>
<li>只要有 iterator 接口的数据结构,都可以使用 for of循环。
<ul>
<li>数组 Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>arguments对象</li>
<li>Nodelist对象, 就是获取的dom列表集合</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>for..in(ES5):</p>
<ul>
<li>适用于<strong>遍历对象</strong>而产生的，不适用于遍历数组。</li>
<li>只能获得对象的<strong>键名</strong>，不能获得键值</li>
<li>会遍历整个对象的原型链；</li>
<li>返回数组中所有可枚举的属性名；</li>
</ul>
</li>
<li>
<p>forEach</p>
<ul>
<li>无法中途跳出，<code>break</code> 命令或 <code>return</code> 命令都不能奏效</li>
<li>总是返回undefined</li>
<li>对数组的每个元素执行一次提供的函数。</li>
</ul>
</li>
</ol>
<pre class="hljs"><code><div>  array.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>{
    <span class="hljs-built_in">console</span>.log(element);
  });
  <span class="hljs-comment">//语法</span>
  array.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,array</span>)</span>{
　　　<span class="hljs-comment">//code something</span>
　});
</div></code></pre>
<h3 id="map">map()</h3>
<p>原数组中的每个元素调用一个指定方法后，返回返回值组成的新数组。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pow</span>(<span class="hljs-params">x</span>)</span>{  <span class="hljs-comment">//定义一个平方函数</span>
    <span class="hljs-keyword">return</span> x*x;
}

<span class="hljs-keyword">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];
<span class="hljs-keyword">var</span> result = arr.map(pow);  <span class="hljs-comment">//map()传入的是函数对象本身</span>
<span class="hljs-built_in">console</span>.log(result);       <span class="hljs-comment">//结果：[1,4,9,16,25,36,49,64,81];</span>
</div></code></pre>
<h3 id="reduce">reduce()</h3>
<p>为数组中的每一个元素依次执行回调函数（不包括数组中被删除或从未被赋值的元素），返回一个具体的结果。</p>
<pre class="hljs"><code><div>[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)

<span class="hljs-comment">//语法</span>
arr.reduce(callback,[initialValue])
</div></code></pre>
<ul>
<li>callback （执行数组中每个值的函数，包含四个参数）
<ul>
<li>previousValue （第一项的值或者上一次叠加的结果值，或者是提供的初始值  - （initialValue））</li>
<li>currentValue （数组中当前被处理的元素）</li>
<li>index （当前元素在数组中的索引）</li>
<li>array （数组本身）</li>
</ul>
</li>
<li>initialValue （作为第一次调用 callback 的第一个参数，可以控制返回值的格式）</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span>  arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
sum = arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prev, cur, index, arr</span>) </span>{
    <span class="hljs-built_in">console</span>.log(prev, cur, index);   <span class="hljs-comment">//输出的是第一项的值或上一次叠加的结果，正在被处理的元素，正在被处理的元素的索引值</span>
    <span class="hljs-keyword">return</span> prev + cur;
})
<span class="hljs-built_in">console</span>.log(arr, sum); <span class="hljs-comment">//输入数组本身和最后的结果</span>
</div></code></pre>
<h3 id="%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C">常见操作</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数/使用 [可选]</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shift</code></td>
<td>-</td>
<td><strong>删除</strong>原数组<strong>第一项</strong>，并<strong>返回</strong>删除元素的<strong>值</strong>；如果数组为空则返回 <code>undefined</code></td>
</tr>
<tr>
<td><code>unshift</code></td>
<td>(<code>要添加的东西</code>)</td>
<td>将<strong>参数添加</strong>到原数组<strong>开头</strong>，并返回<strong>数组的长度</strong></td>
</tr>
<tr>
<td><code>pop</code></td>
<td>-</td>
<td><strong>删除</strong>原数组<strong>最后一项</strong>，并<strong>返回</strong>删除元素的<strong>值</strong>；如果数组为空则返回 undefined</td>
</tr>
<tr>
<td><code>push</code></td>
<td>(<code>要添加的东西</code>)</td>
<td>将<strong>参数添加</strong>到原数组<strong>末尾</strong>，并返回数组的<strong>长度</strong></td>
</tr>
<tr>
<td><code>concat</code></td>
<td><code>c = a.concat(b);</code></td>
<td>合并两个数组，如果是使用ES6语法也可以用扩展运算符 <code>…</code> 来代替</td>
</tr>
<tr>
<td><code>splice</code></td>
<td>(<code>start,[deleteCount],[val1,val2,…]</code>)</td>
<td>从<strong>start位置</strong>开始<strong>删除deleteCount项</strong>，并从<strong>该位置起插入</strong>。<strong>原数组改变</strong></td>
</tr>
<tr>
<td><code>reverse</code></td>
<td>-</td>
<td>将数组反序</td>
</tr>
<tr>
<td><code>sort</code></td>
<td>(<code>function</code>)</td>
<td>按指定的参数对数组进行<strong>排序</strong></td>
</tr>
<tr>
<td><code>join</code></td>
<td>(<code>separator</code>)</td>
<td>将<strong>数组</strong>的元素<strong>组起一个字符串</strong>，以 <strong>separator 为分隔符</strong>，省略的话则用<strong>默认用逗号</strong>为分隔符</td>
</tr>
<tr>
<td><code>slice</code></td>
<td>(<code>start,[end]</code>)</td>
<td>规定从何处开始选取，该参数为负数，则表示从原数组中的倒数第几个元素开始提取.[start,end) <strong>原数组不改变</strong></td>
</tr>
<tr>
<td><code>map()</code></td>
<td>实例如下</td>
<td>map 作用是映射调用此方法的数组。按照原始数组元素顺序依次处理元素。不会改变原始数组，返回新数组，长度和原始数组一致</td>
</tr>
</tbody>
</table>
<pre class="hljs"><code><div><span class="hljs-built_in">Array</span>.map(<span class="hljs-function">(<span class="hljs-params">item,index,arr</span>)=&gt;</span>{
 <span class="hljs-comment">//item =&gt; 数组的每一项</span>
 <span class="hljs-comment">//index =&gt; 数组每一项的索引</span>
 <span class="hljs-comment">//arr =&gt; 原数组</span>
})
实例：
<span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
<span class="hljs-keyword">let</span> newArr = arr.map(<span class="hljs-function">(<span class="hljs-params">item,index,arr</span>)=&gt;</span>{
         <span class="hljs-keyword">return</span> item+<span class="hljs-number">1</span>
})
<span class="hljs-comment">//newArr = [2,3,4]</span>
</div></code></pre>
<h2 id="%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</h2>
<h3 id="%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2">数组转化字符串</h3>
<ul>
<li>toString()</li>
<li>toLocalString()</li>
<li>join()            指定分隔符:可以传递一个参数作为分隔符来连接每个元素。如果省略参数，默认使用逗号作为分隔符</li>
<li>split()           方法是 String 对象方法，与 join() 方法操作正好相反。</li>
</ul>
<h2 id="%E4%BA%8B%E4%BB%B6">事件</h2>
<h3 id="%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1">事件冒泡</h3>
<p>就是点击最里面的元素，会触发父元素的方法。</p>
<pre class="hljs"><code><div>event.stopPropagation() <span class="hljs-comment">//阻止事件的冒泡方法</span>
event.preventDefault() <span class="hljs-comment">//阻止默认事件的方法</span>
</div></code></pre>
<h3 id="%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98">事件委托</h3>
<p>我们要给每一个按钮绑定一个事件，但是这样遍历，太消耗性能了，于是我们直接给父元素绑定即可完成。</p>
<h3 id="%E4%BA%8B%E4%BB%B6%E6%8D%95%E8%8E%B7">事件捕获</h3>
<p>当鼠标点击或者触发 dom 事件时（被触发 dom 事件的这个元素被叫作事件源），浏览器会从根节点 =&gt;事件源（<strong>由外到内</strong>）进行事件传播。</p>
<p>在捕获的过程中，<strong>最外层</strong>（根）元素的事件<strong>先被触发</strong>，然后依次向内执行，直到触发最里面的元素（事件源)。</p>
<h2 id="%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">内存管理</h2>
<h3 id="%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6">内存回收</h3>
<p>JS 有自动垃圾回收机制 ： 垃圾回收机制自动回收<strong>不再使用</strong>的内存</p>
<p>局部变量：一般函数运行结束，没有其他引用（闭包），那么该变量会被回收</p>
<p>全局变量：直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收。</p>
<h3 id="%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">内存泄漏</h3>
<p>己动态分配的内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<h4 id="%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2">常见的内存泄露</h4>
<ol>
<li>意外的全局变量（就是上面所说的全局变量不能被js垃圾回收机制回收）
<ul>
<li>一个<strong>未声明变量</strong>的使用【也就是没有var/let/const】，会在全局对象中创建一个新的变量；在浏览器环境下，全局对象就是window</li>
<li><strong>解决</strong>：变量使用完后将变量的内存释放/开严格模式</li>
</ul>
</li>
<li>计时器和回调函数
<ul>
<li>定时器<code>setinterval</code>或者<code>settimeout</code>在不需要使用的时候，没有被clear，定时器无法被内存回收，导致定时器的回调函数及其内部依赖的变量都不能被回收，这就会造成内存泄漏。</li>
<li>如果你没有回收定时器，整个定时器依然有效, 不但定时器无法被内存回收， 定时器的<strong>回调函数</strong>和<strong>回调函数中的依赖</strong>也无法回收。在这个案例中定时器的回调函数和回调函数里面的的**依赖变量（serverData ）**也无法被回收。</li>
<li><strong>解决</strong>：当不需要interval定时器或者timeout定时器的时候，调用<code>clearinterval</code>或者<code>cleartimeout</code>清除定时器</li>
</ul>
</li>
<li>DOM: 将dom元素已经移除，但是对dom元素的引用没有清除，也会造成内存泄露
<ul>
<li><strong>解决：</strong> 利用null释放内存</li>
</ul>
</li>
<li>闭包
<ul>
<li>手动释放内存,设置为null</li>
</ul>
</li>
</ol>
<h4 id="%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D">如何定位</h4>
<p>Chrome DevTools里的Performance面板和Memory面板可以用来定位内存问题</p>
<p>排查内存泄漏的第一步，就是要先梳理一遍自己的代码，看一下哪部分内存的升高是合理的，哪部分内存的升高是不合理的。</p>
<ol>
<li>先用Performance录制
当我们怀疑页面发生了内存泄漏的时候，可以先用Performance<strong>录制</strong>一段时间内页面的性能变化。你只需要切换到Performance面板，点击Record，然后在页面上正常操作一段时间，最后停止录制即可。</li>
</ol>
<p>如果录制结束后，看到内存的<strong>下限</strong>在不断升高的话，你就要注意了 —— 这里有可能发生了内存泄漏。</p>
<p>除了内存增长曲线，<strong>Nodes</strong>（Dom节点数曲线）、<strong>Document</strong>曲线以及<strong>Listener</strong>曲线也同样值得关注，有时候它们对内存问题的定位也很有帮助。</p>
<ol start="2">
<li>用Memory面板来进一步定位泄漏的源头</li>
</ol>
<ul>
<li>从Memory的主界面开始，点击左上角的圆点就可以记录下当前的堆内存快照（heap snapshot）了</li>
<li>打开DevTools, 切换至Memory面板</li>
<li>先记录一个堆内存快照</li>
<li>在你的页面上执行可能发生泄漏的操作</li>
<li>再记录一个堆内存快照</li>
<li>重复执行多几遍步骤3</li>
<li>最后记录一个堆内存快照</li>
<li>选择最后一个堆内存快照，找到顶栏的“All objects”, 切换至”Objects allocated between snapshots 1 and 2”（也可以对2，3执行同样的操作）</li>
</ul>
<p>如果Shallow Size = Retained Size，说明基本没怎么泄漏。而如果Retained Size &gt; Shallow Size，就需要多加注意了。</p>
<h3 id="%E5%A0%86%E5%86%85%E5%AD%98%E6%A0%88%E5%86%85%E5%AD%98">堆内存/栈内存</h3>
<p><strong>栈内存</strong>：</p>
<ul>
<li>主要用于存储各种<strong>基本类型</strong>的变量
<ul>
<li>包括Boolean、Number、String、Undefined、Null，</li>
<li>以及<strong>对象变量的指针</strong>，</li>
<li>这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。</li>
</ul>
</li>
<li>堆内存主要负责像对象Object这种变量类型的存储</li>
</ul>
<p><strong>堆内存</strong>：</p>
<ul>
<li>主要负责像<strong>对象Object</strong>这种变量类型的存储</li>
</ul>
<h5 id="const">const</h5>
<p>当我们定义一个const对象的时候，我们说的常量其实是指针，就是const对象对应的堆内存指向是不变的，但是堆内存中的数据本身的大小或者属性是可变的。</p>
<p>而对于const定义的基础变量而言，这个值就相当于const对象的指针，是不可变。</p>
<p>知道了const在内存中的存储，那么const、let定义的变量不能二次定义的流程也就比较容易猜出来了，每次使用const或者let去初始化一个变量的时候，会首先遍历当前的内存栈，看看有没有重名变量，有的话就返回错误。</p>
<h5 id="new">new</h5>
<p>new的对象是放在堆里的，返回一个指针</p>
<pre class="hljs"><code><div><span class="hljs-comment">// a b相当于两个指针，指向的不同的堆内存中的对象</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">'123'</span>) 
<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">'123'</span>)
<span class="hljs-built_in">console</span>.log(a==b, a===b)
&gt;&gt;&gt; <span class="hljs-literal">false</span> <span class="hljs-literal">false</span>
</div></code></pre>
<h2 id="%E5%AD%98%E5%82%A8%E9%97%AE%E9%A2%98">存储问题</h2>
<h3 id="localstoragesessionstoragecookies">localstorage/sessionstorage/cookies</h3>
<h4 id="%E7%9B%B8%E5%90%8C%E7%82%B9">相同点</h4>
<p>Cookie、SessionStorage和LocalStorage都是存储在浏览器本地的</p>
<h4 id="%E4%B8%8D%E5%90%8C%E7%82%B9">不同点</h4>
<ol>
<li>
<p>cookie是由<strong>服务器端写入</strong>的，而SessionStorage、 LocalStorage都是由<strong>前端写入</strong>的</p>
</li>
<li>
<p>cookie的生命周期是由服务器端在写入的时候就设置好的，LocalStorage是写入就一直存在，<strong>除非手动清除</strong>，SessionStorage是<strong>页面关闭</strong>的时候就会<strong>自动清除</strong>。</p>
</li>
<li>
<p>cookie的存储空间比较小大概4KB，SessionStorage、 LocalStorage存储空间比较大，大概5M。</p>
</li>
<li>
<p>Cookie、SessionStorage、 LocalStorage数据共享都遵循同源原则，SessionStorage 还<strong>限制必须是同一个页面</strong>。</p>
</li>
<li>
<p>在前端给后端发送请求的时候<strong>会自动携带Cookie中的数据</strong>，但SessionStorage、 LocalStorage不会</p>
</li>
<li>
<p>它们的应用场景也不同，Cookie一般用于存储登录验证信息SessionID或者token，LocalStorage常用于存储不易变动的数据，减轻服务器的压力，SessionStorage可以用来检测用户是否是刷新进入页面，如音乐播放器恢复播放进度条的功能。</p>
</li>
</ol>
<h4 id="%E6%99%AE%E9%80%9A%E4%BD%BF%E7%94%A8">普通使用</h4>
<pre class="hljs"><code><div><span class="hljs-comment">//！！！基础变量</span>
<span class="hljs-comment">// 当我们存基本变量时</span>
localStorage.setItem(<span class="hljs-string">'基本变量'</span>, <span class="hljs-string">'这是一个基本变量'</span>)
<span class="hljs-comment">// 当我们取值时</span>
localStorage.getItem(<span class="hljs-string">'基本变量'</span>)
<span class="hljs-comment">// 当我们删除时</span>
localStorage.removeItem(<span class="hljs-string">'基本变量'</span>)

<span class="hljs-comment">//！！！引用变量</span>
<span class="hljs-comment">// 当我们存引用变量时</span>
localStorage.setItem(<span class="hljs-string">'引用变量'</span>, <span class="hljs-built_in">JSON</span>.stringify(data))
<span class="hljs-comment">// 当我们取值时</span>
<span class="hljs-keyword">const</span> data = <span class="hljs-built_in">JSON</span>.parse(localStorage.getItem(<span class="hljs-string">'引用变量'</span>))
<span class="hljs-comment">// 当我们删除时</span>
localStorage.removeItem(<span class="hljs-string">'引用变量'</span>)

<span class="hljs-comment">//清空</span>
localStorage.clear()
</div></code></pre>
<h4 id="%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83">命名规范</h4>
<ol>
<li>比如我们存用户信息会使用user作为 key 来存储</li>
<li>存储主题的时候用theme 作为 key 来存储</li>
<li>存储令牌时使用token作为 key 来存储
其实这是很有问题的，咱们都知道，同源的两个项目，它们的localStorage是互通的。</li>
</ol>
<p>我举个例子吧比如我现在有两个项目，它们在同源https://www.sunshine.com下，这两个项目都需要往localStorage中存储一个 key 为name的值，那么这就会造成两个项目的name互相顶替的现象，也就是互相污染现象：</p>
<pre class="hljs"><code><div>项目名 + 当前环境 + 项目版本 + 缓存key
SUNSHINE_ADMIN_DEV_2.11_NAME
</div></code></pre>
<h4 id="%E6%97%B6%E6%95%88%E6%80%A7">时效性</h4>
<p>咱们都知道localStorage、sessionStorage这两个的生命周期分别是</p>
<ul>
<li>localStorage：除非<strong>手动清除</strong>，否则一直存在</li>
<li>sessionStorage：生命结束于当前<strong>标签页的关闭</strong>或<strong>浏览器的关闭</strong></li>
</ul>
<p>设置缓存key时，将value包装成一个对象，对象中有相应的时效时段，当下一次想获取缓存值时，判断有无超时，不超时就获取value，超时就删除这个缓存
<img src="./img/2023-01-12-16-25-11.png" alt=""></p>
<h4 id="%E9%9A%90%E7%A7%98%E6%80%A7">隐秘性</h4>
<p>其实这个好理解，你们想想，当咱们把咱们想缓存的东西，存在localStorage、sessionStorage中，在开发过程中，确实有利于咱们的开发，咱们想看的时候也是一目了然，点击Application就可以看到。</p>
<p>但是，一旦产品上线了，用户也是可以看到缓存中的东西的，而咱们肯定是会想：<strong>有些东西可以让用户看到，但是有些东西我不想让你看到</strong></p>
<p>加密很简单，直接使用crypto-js进行对数据的加密，使用这个库里的encrypt、decrypyt进行加密、解密</p>
<h2 id="%E8%B7%A8%E5%9F%9F">跨域</h2>
<h3 id="%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5">同源策略</h3>
<p><strong>同源策略</strong>限制了从<strong>同一个源加载的文档或脚本</strong>如何与<strong>来自另一个源的资源</strong>进行交互。这是一个用于<strong>隔离</strong>潜在恶意文件的重要安全机制</p>
<p>简单来说，在一个域名地址下的网页，如果请求一个受到同源策略限制的另一个域名地址接口的时候，就会报错</p>
<p>同源策略不仅仅是浏览器这边做了限制，在服务端也是有限制的</p>
<blockquote>
<p>同源： 协议、主机、端口 一致</p>
</blockquote>
<h3 id="jsonp">JSONP</h3>
<h4 id="src%E5%92%8Chref%E5%B1%9E%E6%80%A7"><code>src</code>和<code>href</code>属性</h4>
<p>HTML的标签中有一个属性是可以请求外部地址的，那就是src和href属性。可以请求外部地址的js或者css，请求cdn服务器上的公共资源，并且不会出现问题，所以根据src的这一个特性，优秀的工程师们想到一个解决跨域的办法，俗称JSONP。</p>
<p>主要思路是生成一个<code>&lt;script&gt;</code>标签，里头src属性赋值为要请求的文件/资源</p>
<pre class="hljs"><code><div><span class="hljs-meta">&lt;!doctype <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>JSONP<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">data</span>) </span>{
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我叫<span class="hljs-subst">${data.name}</span>`</span>);
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我今年<span class="hljs-subst">${data.age}</span>岁`</span>);
      <span class="hljs-keyword">let</span> jsonpScript = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">'jsonpScript'</span>)[<span class="hljs-number">0</span>];
      <span class="hljs-built_in">document</span>.body.removeChild(jsonpScript);
    }
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonpRequest</span>(<span class="hljs-params">callback</span>) </span>{
      <span class="hljs-keyword">let</span> jsonpScript = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'script'</span>);
      jsonpScript.src = <span class="hljs-string">`http://www.zhanwuzha.com/jsonp/js/index.js?callback=<span class="hljs-subst">${callback}</span>`</span>;
      jsonpScript.className = <span class="hljs-string">'jsonpScript'</span>;
      <span class="hljs-built_in">document</span>.body.appendChild(jsonpScript);
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"jsonpRequest('print')"</span>&gt;</span>发个JSONP请求<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// jsonp/js/index.js</span>
print({
    <span class="hljs-attr">name</span>: <span class="hljs-string">'前端战五渣'</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>
  })

</div></code></pre>
<p>其实JSONP并不算真正意义上的AJAX请求，只是<strong>请求了一个js文件并且执行</strong>了，而且这种跨域方法只能进行<strong>GET请求</strong></p>
<h3 id="cors%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB">CORS[跨域资源共享]</h3>
<p>它允许浏览器向跨源服务器，发出 <code>XMLHttpRequest</code> 请求，从而克服了<code>AJAX</code>只能同源使用的限制。</p>
<h4 id="%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82">简单请求</h4>
<p>只要满足以下条件的请求，就属于简单请求</p>
<ol>
<li>请求方法为<strong>HEAD</strong>、<strong>GET</strong>或者<strong>POST</strong>中的一种</li>
<li>HTTP的头信息不超过以下几种字段Accept、Accept-Language、Content-Language、Last-Event-ID以及Content-Type的值只限于application/x-www-form-urlencoded、multipart/form-data、text/plain三个</li>
</ol>
<p>对于简单请求来说，从浏览器发出请求的时候，浏览器会自动在请求头中添加一个字段Origin，值为发出请求网页的源地址</p>
<p><img src="https://pic3.zhimg.com/80/v2-a30a1883fcbf07f8c7d86e9b73511186_1440w.webp" alt=""></p>
<ul>
<li>如果<code>Origin</code>的值<strong>不在指定</strong>的许可范围
<ul>
<li>服务端返回一个正常的HTTP回应。
<ul>
<li>这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。</li>
<li>注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</li>
</ul>
</li>
</ul>
</li>
<li>如果<code>Access-Control-Allow-Origin</code>字段正好跟带过去的<code>Origin</code>的<strong>值一样</strong>，则返回对应的数据，完成一次请求。</li>
</ul>
<p>总的来说，CORS实现跨域的方法就是根据<strong>请求头</strong>的<code>Origin</code>值和<strong>响应头</strong>的<code>Access-Control-Request-Headers</code>和<code>Access-Control-Request-Method</code>的值进行比对，通过了就可以请求成功，没通过就请求失败。</p>
<h4 id="%E9%9D%9E%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82">非简单请求</h4>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<strong>PUT</strong>或<strong>DELETE</strong>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<h4 id="option%E8%AF%B7%E6%B1%82">option请求</h4>
<p>在进行非简单请求之前，浏览器会在正式请求之前发送一次<strong>预检请求</strong>，这就是有时候我们会在控制台中看到的<strong>option请求</strong>，就是说，正式请求之前，浏览器会去问服务端我这个地址能不能访问你，如果可以，浏览器才会发送正式的请求，否则报错。</p>
<h2 id="ajax">Ajax</h2>
<p>AJAX代表异步JavaScript和XML。</p>
<p>它是一组用于<strong>异步显示数据</strong>的相关技术。换句话说，它在不重新加载网页的情况下<strong>发送和检索数据</strong>。</p>
<pre class="hljs"><code><div><span class="hljs-comment">// 原生js</span>
<span class="hljs-comment">//创建 XMLHttpRequest 对象</span>
<span class="hljs-keyword">var</span> ajax = <span class="hljs-keyword">new</span> XMLHttpRequest();
<span class="hljs-comment">//规定请求的类型、URL 以及是否异步处理请求。</span>
ajax.open(<span class="hljs-string">'GET'</span>,url,<span class="hljs-literal">true</span>);
<span class="hljs-comment">//发送信息至服务器时内容编码类型</span>
ajax.setRequestHeader(<span class="hljs-string">"Content-type"</span>, <span class="hljs-string">"application/x-www-form-urlencoded"</span>); 
<span class="hljs-comment">//发送请求</span>
ajax.send(<span class="hljs-literal">null</span>);  
<span class="hljs-comment">//接受服务器响应数据</span>
ajax.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (obj.readyState == <span class="hljs-number">4</span> &amp;&amp; (obj.status == <span class="hljs-number">200</span> || obj.status == <span class="hljs-number">304</span>)) { 
    }
};
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">// jQuery</span>
$.ajax({				<span class="hljs-comment">//交互方式 $.get，$.post，$.getJSON</span>
	<span class="hljs-attr">async</span>:				<span class="hljs-comment">//请求同步异步，默认true异步</span>
	type:				<span class="hljs-comment">//请求类型：GET/POST				</span>
	url:				<span class="hljs-comment">//请求的网站地址</span>
	data:				<span class="hljs-comment">//提交的数据，参数</span>
	contentType:		<span class="hljs-comment">//请求的MIME媒体类型：application/x-www-form-urlencoded（默认）、application/json;charset=UTF-8</span>
	dataType:			<span class="hljs-comment">//服务器返回MIME类型：xml/html/script/json/jsonp</span>
	success: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{	<span class="hljs-comment">//请求成功，回调函数，data封装网站返回的数据</span>
		<span class="hljs-built_in">console</span>.log( data );
	},
	<span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>{		<span class="hljs-comment">//请求失败回调函数，e封装错误信息</span>
		<span class="hljs-built_in">console</span>.log(e.status);			<span class="hljs-comment">//状态码</span>
		<span class="hljs-built_in">console</span>.log(e.responseText);	<span class="hljs-comment">//错误信息</span>
	}
})

</div></code></pre>
<h3 id="xmlhttprequest%E7%9A%84%E5%B1%9E%E6%80%A7">XMLHttpRequest的属性</h3>
<ul>
<li><code>onReadyStateChange</code> - 只要readystate属性发生变化，就会调用它。</li>
<li><code>readyState</code> - 表示请求的状态。</li>
<li><code>responseText</code> - 它将响应作为文本返回。</li>
<li><code>responseXML</code> - 它以XML格式返回响应。</li>
<li><code>status</code> - 返回请求的状态编号。</li>
<li><code>statusText</code> - 返回状态的详细信息。</li>
</ul>
<h3 id="xmlhttprequest%E7%9A%84%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88">XMLHttpRequest的重要方法是什么？</h3>
<ul>
<li><code>abort()</code> - 用于取消当前请求。</li>
<li><code>getAllResponseHeaders()</code> - 返回标题详细信息。</li>
<li><code>getResponseHeader()</code> - 返回特定的标题详细信息。</li>
<li><code>open()</code> - 用于打开请求。
<ul>
<li><code>open(method,URL)</code> - 它打开指定get或post方法和URL的请求。</li>
<li><code>open(method,URL,async)</code> - 它与上面相同但是指定异步或不指定。</li>
<li><code>open(method,URL,async,userName,password)</code> - 与上面相同，但指定用户名和密码。</li>
</ul>
</li>
<li><code>send()</code> - 用于发送请求。
<ul>
<li><code>send()</code> - 它发送get请求</li>
<li><code>send(string)</code> - 发送帖子请求。</li>
</ul>
</li>
<li><code>setRequestHeader()</code> - 它添加了请求标头。</li>
</ul>
<h3 id="ajax%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">AJAX有哪些安全问题？</h3>
<ul>
<li>AJAX源代码是可读的</li>
<li>攻击者可以将脚本插入系统</li>
</ul>
<h3 id="axios">axios</h3>
<p>Vue中封装了ajax并增强了它，在异步并发处理优于原生ajax。称为：axios（ajax input output system）</p>
<pre class="hljs"><code><div><span class="hljs-comment">//get请求方式一：</span>
axios({
		<span class="hljs-comment">// 默认请求方式为get</span>
		<span class="hljs-attr">method</span>: <span class="hljs-string">'get'</span>,
		<span class="hljs-attr">url</span>: <span class="hljs-string">'api'</span>,
		<span class="hljs-comment">// 传递参数</span>
		<span class="hljs-attr">params</span>: {
			<span class="hljs-attr">key</span>: value
		},
		<span class="hljs-comment">// 设置请求头信息</span>
		<span class="hljs-attr">headers</span>: {
			<span class="hljs-attr">key</span>: value
		}
		<span class="hljs-attr">responseType</span>: <span class="hljs-string">'json'</span>
	}).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
		<span class="hljs-comment">// 请求成功</span>
		<span class="hljs-keyword">let</span> res = response.data;
		<span class="hljs-built_in">console</span>.log(res);
	}).catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
		<span class="hljs-comment">// 请求失败，</span>
		<span class="hljs-built_in">console</span>.log(error);
});
<span class="hljs-comment">//get请求方式二：</span>
axios.get(<span class="hljs-string">"api"</span>, {
	<span class="hljs-comment">// 传递参数</span>
	<span class="hljs-attr">params</span>: {
		<span class="hljs-attr">key</span>: value
	},
    <span class="hljs-comment">// 设置请求头信息，可以传递空值</span>
	<span class="hljs-attr">headers</span>: {
		<span class="hljs-attr">key</span>: value
	}
}).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
	<span class="hljs-comment">// 请求成功</span>
	<span class="hljs-keyword">let</span> res = response.data;
	<span class="hljs-built_in">console</span>.log(res);
}).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
	<span class="hljs-comment">// 请求失败，</span>
	<span class="hljs-built_in">console</span>.log(error);
});

<span class="hljs-comment">//post请求方式一：</span>
<span class="hljs-comment">// 注：post请求方法有的要求参数格式为formdata格式，此时需要借助 Qs.stringify()方法将对象转换为字符串</span>
<span class="hljs-keyword">let</span> obj = qs.stringify({
	<span class="hljs-attr">key</span>: value
});
axios({
	<span class="hljs-attr">method</span>: <span class="hljs-string">'post'</span>,
	<span class="hljs-attr">url</span>: <span class="hljs-string">'api'</span>,
	<span class="hljs-comment">// 传递参数</span>
	<span class="hljs-attr">data</span>: obj,
	<span class="hljs-comment">// 设置请求头信息</span>
	<span class="hljs-attr">headers</span>: {
		<span class="hljs-attr">key</span>: value
	},
	<span class="hljs-attr">responseType</span>: <span class="hljs-string">'json'</span>
}).then(<span class="hljs-function">(<span class="hljs-params">response </span>)=&gt;</span> {
	<span class="hljs-comment">// 请求成功</span>
	<span class="hljs-keyword">let</span> res = response.data;
	<span class="hljs-built_in">console</span>.log(res);
}).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
	<span class="hljs-comment">// 请求失败，</span>
	<span class="hljs-built_in">console</span>.log(error);
});
<span class="hljs-comment">//post请求方式二：</span>
<span class="hljs-keyword">let</span> data = {
	<span class="hljs-attr">key</span>: value
},
headers = {
	<span class="hljs-attr">USERID</span>: <span class="hljs-string">""</span>,
	<span class="hljs-attr">TOKEN</span>: <span class="hljs-string">""</span>
};
<span class="hljs-comment">// 若无headers信息时，可传空对象占用参数位置</span>
axios.post(<span class="hljs-string">"api"</span>, qs.stringify(data), {
	headers
}
}).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> {
	<span class="hljs-comment">// 请求成功</span>
	<span class="hljs-keyword">let</span> res = response.data;
	<span class="hljs-built_in">console</span>.log(res);
}).catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> {
	<span class="hljs-comment">// 请求失败，</span>
	<span class="hljs-built_in">console</span>.log(error);
});
</div></code></pre>
<ul>
<li>post请求的时候参数通过data进行传递</li>
<li>get请求的时候参数通过params进行传递</li>
</ul>
<blockquote>
<p>axios请求头的 Content-Type 默认是 application/json，而postman默认的是 application/x-www-form-urlencoded。</p>
</blockquote>
<p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，它本身具有以下特征：
从浏览器中创建 XMLHttpRequest</p>
<ul>
<li>支持 Promise API</li>
<li>客户端支持防止CSRF
<ul>
<li>就是让你的每个请求都带一个从cookie中拿到的key，根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。</li>
</ul>
</li>
<li>提供了一些并发请求的接口（重要，方便了很多的操作）</li>
<li>从 node.js 创建</li>
<li>http 请求 拦截请求和响应 转换请求和响应数据 取消请求</li>
<li>自动转换JSON数据</li>
</ul>

</body>
</html>
