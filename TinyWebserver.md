服务器程序通常需要处理三类事件:
 - I/O事件
 - 信号
 - 定时事件
---
有两种事件处理模式
1. **Reactor模式**：
   - 要求主线程（I/O处理单元）只负责监听文件描述符上**是否有事件发生（可读、可写）**
   - 若有，则立即通知工作线程（逻辑单元），将socket可读可写事件**放入请求队列**，交给工作线程处理
2. **Proactor模式**：
   - 将所有的**I/O操作都交给主线程和内核**来处理（进行读、写
   - **工作线程仅负责处理逻辑**，如主线程读完成后`users[sockfd].read()`，选择一个工作线程来处理客户请求`pool->append(users + sockfd)`。
---
同步（阻塞）I/O：
- 在一个线程中，CPU执行代码的速度极快
- 然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。

异步（非阻塞）I/O：
- 当代码需要执行一个耗时的IO操作时，它只发出IO指令，并**不等待**IO结果，然后就去执行其他代码了。
- 一段时间后，当IO返回结果时，再通知CPU进行处理。
---
Linux下有三种IO复用方式：`epoll`，`select`和`poll`，为什么用epoll
1. 文件描述符
- 对于`select`和`poll`来说，所有**文件描述符**都是在用户态被加入其文件描述符集合的，每次调用都需要将整个**集合拷贝到内核态**；
- `epoll`则将整个文件描述符集合**维护在内核态**，每次**添加文件描述符**的时候都需要**执行一个系统调用**。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll**可能会慢于**select和poll由于这些大量的系统调用开销。
2. 描述文件描述符集合的结构
- `select`使用**线性表**描述文件描述符集合，文件描述符有上限；
- `poll`使用**链表**来描述；
-` epoll`底层通过**红黑树**来描述，并且维护一个**ready list**，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。
3. 文件描述符就绪
- `select`和`poll`的**最大开销**来自内核**判断是否有文件描述符就绪**这一过程：
  - 每次执行`select`或`poll`调用时，它们会采用**遍历的方式**，遍历整个文件描述符集合去判断各个文件描述符是否有活动；
- epoll则不需要去以这种方式检查，当有活动产生时，会**自动触发epoll回调函数**通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。
4. LT模式
- select和poll都只能工作在相对低效的LT模式下，
- epoll同时支持LT和ET模式。Epoll对文件操作符的操作有两种模式：LT（电平触发）和ET（边缘触发），二者的区别在于当你调用`epoll_wait`的时候内核里面发生了什么：
  - LT（电平触发）：类似select，LT会去**遍历**在epoll**事件表中每个文件描述符**，来观察**是否有我们感兴趣的事件发生**
    - 如果有（触发了该文件描述符上的回调函数），epoll_wait就会以非阻塞的方式返回。
    - 若该epoll事件没有被处理完（没有返回EWOULDLOCK），该事件还会被后续的epoll_wait再次触发。
  - ET（边缘触发）：ET在发现有我们感兴趣的事件发生后，立即返回，并且sleep这一事件的epoll_wait，不管该事件有没有结束

- 综上，当监测的**fd数量较小**，且各个**fd都很活跃**的情况下，建议使用select和poll；
- 当监听的**fd数量较多**，且**单位时间仅部分fd活跃**的情况下，使用epoll会明显提升性能。
---
