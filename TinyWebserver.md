服务器程序通常需要处理三类事件:
 - I/O事件
 - 信号
 - 定时事件
---
有两种事件处理模式
1. **Reactor模式**：
   - 要求主线程（I/O处理单元）只负责监听文件描述符上**是否有事件发生（可读、可写）**
   - 若有，则立即通知工作线程（逻辑单元），将socket可读可写事件**放入请求队列**，交给工作线程处理
2. **Proactor模式**：
   - 将所有的**I/O操作都交给主线程和内核**来处理（进行读、写
   - **工作线程仅负责处理逻辑**，如主线程读完成后`users[sockfd].read()`，选择一个工作线程来处理客户请求`pool->append(users + sockfd)`。
---
同步（阻塞）I/O：
- 在一个线程中，CPU执行代码的速度极快
- 然而，一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能继续进行下一步操作。这种情况称为同步IO。

异步（非阻塞）I/O：
- 当代码需要执行一个耗时的IO操作时，它只发出IO指令，并**不等待**IO结果，然后就去执行其他代码了。
- 一段时间后，当IO返回结果时，再通知CPU进行处理。
---
Linux下有三种IO复用方式：`epoll`，`select`和`poll`，为什么用epoll
1. 文件描述符
- 对于`select`和`poll`来说，所有**文件描述符**都是在用户态被加入其文件描述符集合的，每次调用都需要将整个**集合拷贝到内核态**；
- `epoll`则将整个文件描述符集合**维护在内核态**，每次**添加文件描述符**的时候都需要**执行一个系统调用**。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll**可能会慢于**select和poll由于这些大量的系统调用开销。
2. 描述文件描述符集合的结构
- `select`使用**线性表**描述文件描述符集合，文件描述符有上限；
- `poll`使用**链表**来描述；
-` epoll`底层通过**红黑树**来描述，并且维护一个**ready list**，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。
3. 文件描述符就绪
- `select`和`poll`的**最大开销**来自内核**判断是否有文件描述符就绪**这一过程：
  - 每次执行`select`或`poll`调用时，它们会采用**遍历的方式**，遍历整个文件描述符集合去判断各个文件描述符是否有活动；
- epoll则不需要去以这种方式检查，当有活动产生时，会**自动触发epoll回调函数**通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。
4. LT模式
- select和poll都只能工作在相对低效的LT模式下，
- epoll同时支持LT和ET模式。Epoll对文件操作符的操作有两种模式：LT（电平触发）和ET（边缘触发），二者的区别在于当你调用`epoll_wait`的时候内核里面发生了什么：
  - LT（电平触发）：类似select，LT会去**遍历**在epoll**事件表中每个文件描述符**，来观察**是否有我们感兴趣的事件发生**
    - 如果有（触发了该文件描述符上的回调函数），epoll_wait就会以非阻塞的方式返回。
    - 若该epoll事件没有被处理完（没有返回EWOULDLOCK），该事件还会被后续的epoll_wait再次触发。
  - ET（边缘触发）：ET在发现有我们感兴趣的事件发生后，立即返回，并且sleep这一事件的epoll_wait，不管该事件有没有结束

- 综上，当监测的**fd数量较小**，且各个**fd都很活跃**的情况下，建议使用select和poll；
- 当监听的**fd数量较多**，且**单位时间仅部分fd活跃**的情况下，使用epoll会明显提升性能。
---
线程池

主线程负责读写，工作线程（线程池中的线程）负责处理逻辑（HTTP请求报文的解析等等）

这个过程是：
1. 通过epoll_wait发现这个**connfd上有可读事件**了（EPOLLIN）
2. 主线程就将这个**HTTP的请求报文**读进这个**连接socket的读缓存**中`users[sockfd].read()`，
3. 然后将该**任务对象（指针）插入线程池**的**请求队列**中`pool->append(users + sockfd)`

线程池的实现还需要依靠**锁机制**以及**信号量**机制来实现线程**同步**，保证操作的原子性。
- 操作工作队列一定要加锁（locker），因为它被所有线程共享。
- 我们用信号量来标识请求队列中的请求数，通过m_queuestat.wait();来等待一个请求队列中待处理的HTTP请求，然后交给线程池中的空闲线程来处理

所谓线程池，就是一个pthread_t类型的普通**数组**，
1. 通过`pthread_create()`函数创建`m_thread_number`个线程
2. 用来执行`worker()`函数以执行每个请求处理函数（HTTP请求的process函数），
3. 通过`pthread_detach()`将线程设置成**脱离态**（detached）后，当这一线程运行结束时，它的**资源会被系统自动回收**，而不再需要在其它线程中对其进行 pthread_join() 操作。

最佳线程数 = CPU当前可使用的Cores数 * 当前CPU的利用率 * (1 + CPU等待时间 / CPU处理时间)

#  线程同步机制封装类
## RAII
- RAII全称是“*Resource Acquisition is Initialization*”，直译过来是“**资源获取**即**初始化**”.


- 在RAII的指导下，我们应该**使用类来管理资源**，将**资源和对象的生命周期绑定**
  - 因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。
  - 在**构造函数**中申请**分配资源**，在**析构函数**中**释放资源**。

- RAII的**核心思想**是将**资源或者状态**与对象的**生命周期绑定**，通过C++的语言机制，实现资源和状态的安全管理,**智能指针**是RAII最好的例子

## 信号量
- 它只支持两种操作：等待(P)和信号(V).假设有信号量`SV`
  - `P`，如果`SV`的值**大于0**，则将其**减一**；若SV的**值为0**，则**挂起**执行
  - `V`，如果有其他进程因为等待SV而挂起，则唤醒；若没有，则将SV值加一
  - 总结： P +1 V -1

- 它只能取自然数值
  - 取值可以是任何**自然数**，最常用的，最简单的信号量是**二进制信号量**，只有0和1两个值.
    - sem_init函数用于**初始化**一个未命名的信号量
    - sem_destroy函数用于**销毁**信号量
    - sem_wait函数将以原子操作方式将信号量**减一**,信号量为0时,sem_wait阻塞 **P操作**
    - sem_post函数以原子操作方式将信号量**加一**,信号量大于0时,唤醒调用sem_post的线程 **V操作**
    - 成功返回0，失败返回errno
```c++
class sem{
    public:
        //构造函数
        sem()
        {
            //信号量初始化
            if(sem_init(&m_sem,0,0)!=0){
                throw std::exception();
            }
        }
        //析构函数
        ~sem()
        {
            //信号量销毁
            sem_destroy(&m_sem);
        }
    private:
        sem_t m_sem;
};
```
## 互斥量
- 互斥锁,也称互斥量,可以保护关键代码段,以确保**独占式访问**.
  - 当进入关键代码段,获得互斥锁将其加锁;
  - 离开关键代码段,唤醒等待该互斥锁的线程.

- pthread_mutex_init函数用于**初始化**互斥锁
- pthread_mutex_destroy函数用于**销毁**互斥锁
- pthread_mutex_lock函数以原子操作方式给互斥锁**加锁** **P操作**
- pthread_mutex_unlock函数以原子操作方式给互斥锁**解锁** **V操作**
- 成功返回0，失败返回errno


## 条件变量

提供了一种线程间的**通知机制**,当某个**共享数据达到某个值**时,**唤醒**等待这个共享数据的线程.

- pthread_cond_init函数用于**初始化**条件变量

- pthread_cond_destroy函数**销毁**条件变量

- pthread_cond_broadcast函数以广播的方式**唤醒所有等待目标条件变量的线程**

- pthread_cond_wait函数用于**等待目标条件变量**.
  - 该函数调用时需要传入 **mutex参数**(加锁的互斥锁) ,
  - 函数执行时,先把**调用线程**放入条件变量的**请求队列**,然后将**互斥锁mutex解锁**,
  - 当函数成功返回为0时,互斥锁会再次被锁上. 
  - 也就是说函数内部会有一次解锁和加锁操作.

```c++
//条件变量的使用机制需要配合锁来使用
//内部会有一次加锁和解锁
//封装起来会使得更加简洁
bool wait()
{
    int ret=0;
    pthread_mutex_lock(&m_mutex);
    ret=pthread_cond_wait(&m_cond,&m_mutex);
    pthread_mutex_unlock(&m_mutex);
    return ret==0;
}
bool signal()
{
    return pthread_cond_signal(&m_cond)==0;
}
```